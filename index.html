<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="黄锦标的博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="黄锦标的博客">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="黄锦标的博客">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>黄锦标的博客</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">黄锦标的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">记录学习点滴，好记性 < 烂笔头！</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-首页">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-ios">
          <a href="/categories/iOS/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-apple"></i> <br>
            
            iOS
          </a>
        </li>
      
        
        <li class="menu-item menu-item-日常">
          <a href="/categories/diary/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-calendar"></i> <br>
            
            日常
          </a>
        </li>
      
        
        <li class="menu-item menu-item-标签">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-归档">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/21/SDWebImage解析之SDImageCache/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DevHuangjb">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="黄锦标的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/21/SDWebImage解析之SDImageCache/" itemprop="url">SDWebImage解析之SDImageCache</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-01-21T09:40:33+08:00">
                2019-01-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>我们知道移动端有三级缓存：远程的服务器，还有本地的内存缓存，硬盘缓存。SDImageCache的存在就是为了解决图片的本地缓存。SDImageCache是SDWebImage一个很重要的部分。为SDWebImage提供了以下功能：</p>
<ul>
<li><p>内存缓存，基于NSCache</p>
</li>
<li><p>异步的硬盘缓存，不会阻塞主线程</p>
</li>
<li><p>提供同步和异步两种方式来查询是否有缓存图片</p>
</li>
<li><p>提供同步和异步来获取缓存的图片</p>
</li>
<li><p>删除缓存图片</p>
</li>
</ul>
<h3 id="SDImageCacheConfig"><a href="#SDImageCacheConfig" class="headerlink" title="SDImageCacheConfig"></a>SDImageCacheConfig</h3><p>我们先来看看SDImageCacheConfig，SDImageCacheConfig是用来图片缓存的配置信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//SDImageCacheConfigExpireType定义的是以什么方式来计算图片的过期时间</span><br><span class="line">typedef NS_ENUM(NSUInteger, SDImageCacheConfigExpireType) &#123;</span><br><span class="line">    //图片最近访问的时间</span><br><span class="line">    SDImageCacheConfigExpireTypeAccessDate,</span><br><span class="line">    //默认：图片最近修改的时间</span><br><span class="line">    SDImageCacheConfigExpireTypeModificationDate</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>SDImageCacheConfig的配置属性和注释如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">@interface SDImageCacheConfig : NSObject</span><br><span class="line"></span><br><span class="line">//预解码图片，默认YES；</span><br><span class="line">//预解码图片可以提升性能，但会消耗太多的内存</span><br><span class="line">@property (assign, nonatomic) BOOL shouldDecompressImages;</span><br><span class="line"></span><br><span class="line">//取消iCloud备份</span><br><span class="line">@property (assign, nonatomic) BOOL shouldDisableiCloud;</span><br><span class="line"></span><br><span class="line">//是否禁用内存缓存</span><br><span class="line">@property (assign, nonatomic) BOOL shouldCacheImagesInMemory;</span><br><span class="line"></span><br><span class="line">//开启SDMemoryCache内部维护的一张图片弱引用表</span><br><span class="line">//好处：当收到内存警告，SDMemoryCache会移除图片的缓存,但是有些图片此时已经被一些诸如UIImageView强引用这，使用这个弱引用表就能访问到图片，避免后面再去query硬盘缓存</span><br><span class="line">@property (assign, nonatomic) BOOL shouldUseWeakMemoryCache;</span><br><span class="line"></span><br><span class="line">//硬盘图片读取的配置选项，默认是0</span><br><span class="line">@property (assign, nonatomic) NSDataReadingOptions diskCacheReadingOptions;</span><br><span class="line"></span><br><span class="line">//把图片存入硬盘的配置选项，默认NSDataWritingAtomic原子操作</span><br><span class="line">@property (assign, nonatomic) NSDataWritingOptions diskCacheWritingOptions;</span><br><span class="line"></span><br><span class="line">//图片最大的缓存时间，默认1星期</span><br><span class="line">@property (assign, nonatomic) NSInteger maxCacheAge;</span><br><span class="line"></span><br><span class="line">//最大的缓存大小，如果maxCacheSize&gt;0,在清除硬盘缓存的时候会先把缓存时间操作maxCacheAge的图片清除掉，然后再清除图片到总缓存大小在maxCacheSize * 0.5以下</span><br><span class="line">@property (assign, nonatomic) NSUInteger maxCacheSize;</span><br><span class="line"></span><br><span class="line">//硬盘缓存图片过期时间的计算方式，默认是最近修改的时间</span><br><span class="line">@property (assign, nonatomic) SDImageCacheConfigExpireType diskCacheExpireType;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>SDImageCacheConfig的初始化函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">static const NSInteger kDefaultCacheMaxCacheAge = 60 * 60 * 24 * 7; // 1 week</span><br><span class="line">- (instancetype)init &#123;</span><br><span class="line">    if (self = [super init]) &#123;</span><br><span class="line">        _shouldDecompressImages = YES;</span><br><span class="line">        _shouldDisableiCloud = YES;</span><br><span class="line">        _shouldCacheImagesInMemory = YES;</span><br><span class="line">        _shouldUseWeakMemoryCache = YES;</span><br><span class="line">        _diskCacheReadingOptions = 0;</span><br><span class="line">        _diskCacheWritingOptions = NSDataWritingAtomic;</span><br><span class="line">        //默认一周的缓存时间</span><br><span class="line">        _maxCacheAge = kDefaultCacheMaxCacheAge;</span><br><span class="line">        _maxCacheSize = 0;</span><br><span class="line">        _diskCacheExpireType = SDImageCacheConfigExpireTypeModificationDate;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="SDImageCache"><a href="#SDImageCache" class="headerlink" title="SDImageCache"></a>SDImageCache</h3><p>SDImageCache使用SDMemoryCache(继承NSCache)来实现内存缓存，使用NSFileManager来进行图片的硬盘存取。</p>
<h4 id="SDMemoryCache-h"><a href="#SDMemoryCache-h" class="headerlink" title="SDMemoryCache.h"></a>SDMemoryCache.h</h4><p>下面我们先来阅读下SDMemoryCache.h文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//用来表示图片的缓存类型</span><br><span class="line">typedef NS_ENUM(NSInteger, SDImageCacheType) &#123;</span><br><span class="line">    //图片来自服务器</span><br><span class="line">    SDImageCacheTypeNone,</span><br><span class="line">    //图片来自硬盘缓存</span><br><span class="line">    SDImageCacheTypeDisk,</span><br><span class="line">    //图片来自内存缓存</span><br><span class="line">    SDImageCacheTypeMemory</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//缓存图片的方式</span><br><span class="line">typedef NS_OPTIONS(NSUInteger, SDImageCacheOptions) &#123;</span><br><span class="line">    //当内存有图片，仍然查询硬盘缓存</span><br><span class="line">    SDImageCacheQueryDataWhenInMemory = 1 &lt;&lt; 0,</span><br><span class="line">    //同步的方式来获取硬盘缓存(默认异步)</span><br><span class="line">    SDImageCacheQueryDiskSync = 1 &lt;&lt; 1,</span><br><span class="line">    //缩小大图(&gt;60M)</span><br><span class="line">    SDImageCacheScaleDownLargeImages = 1 &lt;&lt; 2</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">@interface SDImageCache : NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic, nonnull, readonly) SDImageCacheConfig *config;</span><br><span class="line"></span><br><span class="line">//内存缓存的最大值(图片像素)</span><br><span class="line">@property (assign, nonatomic) NSUInteger maxMemoryCost;</span><br><span class="line"></span><br><span class="line">//内存缓存的最大数量(图片数量)</span><br><span class="line">@property (assign, nonatomic) NSUInteger maxMemoryCountLimit;</span><br><span class="line"></span><br><span class="line">//暴露的单例对象</span><br><span class="line">+ (nonnull instancetype)sharedImageCache;</span><br><span class="line"></span><br><span class="line">//指定命名空间，图片存到对应的沙盒目录中</span><br><span class="line">- (nonnull instancetype)initWithNamespace:(nonnull NSString *)ns;</span><br><span class="line"></span><br><span class="line">//指定命名空间和沙盒目录</span><br><span class="line">- (nonnull instancetype)initWithNamespace:(nonnull NSString *)ns</span><br><span class="line">                       diskCacheDirectory:(nonnull NSString *)directory;</span><br><span class="line"></span><br><span class="line">#pragma mark - Cache paths</span><br><span class="line">//获取磁盘缓存路径</span><br><span class="line">- (nullable NSString *)makeDiskCachePath:(nonnull NSString*)fullNamespace;</span><br><span class="line"></span><br><span class="line">//添加只读路径</span><br><span class="line">- (void)addReadOnlyCachePath:(nonnull NSString *)path;</span><br><span class="line"></span><br><span class="line">#pragma mark - Store Ops</span><br><span class="line"></span><br><span class="line">//异步的方式存储图片到内存和硬盘</span><br><span class="line">- (void)storeImage:(nullable UIImage *)image</span><br><span class="line">            forKey:(nullable NSString *)key</span><br><span class="line">        completion:(nullable SDWebImageNoParamsBlock)completionBlock;</span><br><span class="line"></span><br><span class="line">//异步的方式存储图片到内存和硬盘(可选，toDisk为YES才会存入硬盘)</span><br><span class="line">- (void)storeImage:(nullable UIImage *)image</span><br><span class="line">            forKey:(nullable NSString *)key</span><br><span class="line">            toDisk:(BOOL)toDisk</span><br><span class="line">        completion:(nullable SDWebImageNoParamsBlock)completionBlock;</span><br><span class="line"></span><br><span class="line">//当我们把图片存入硬盘时，需要把图片压缩为二进制格式才能存。当我们下载完图片后，得到的是图片的二进制数据，这个方法提供了imageData的入口，来避免对图片额外的压缩消耗</span><br><span class="line">- (void)storeImage:(nullable UIImage *)image</span><br><span class="line">         imageData:(nullable NSData *)imageData</span><br><span class="line">            forKey:(nullable NSString *)key</span><br><span class="line">            toDisk:(BOOL)toDisk</span><br><span class="line">        completion:(nullable SDWebImageNoParamsBlock)completionBlock;</span><br><span class="line"></span><br><span class="line">//同步的方式把图片的二进制数据存入硬盘</span><br><span class="line">- (void)storeImageDataToDisk:(nullable NSData *)imageData forKey:(nullable NSString *)key;</span><br><span class="line"></span><br><span class="line">#pragma mark - Query and Retrieve Ops</span><br><span class="line"></span><br><span class="line">//异步的方式查询硬盘中是否有key对应的缓存图片</span><br><span class="line">- (void)diskImageExistsWithKey:(nullable NSString *)key completion:(nullable SDWebImageCheckCacheCompletionBlock)completionBlock;</span><br><span class="line"></span><br><span class="line">//同步的方式查询硬盘中是否有key对应的缓存图片</span><br><span class="line">- (BOOL)diskImageDataExistsWithKey:(nullable NSString *)key;</span><br><span class="line"></span><br><span class="line">//同步的方式获取硬盘缓存的图片二进制数据</span><br><span class="line">- (nullable NSData *)diskImageDataForKey:(nullable NSString *)key;</span><br><span class="line"></span><br><span class="line">//异步的方式来获取硬盘缓存的图片</span><br><span class="line">- (nullable NSOperation *)queryCacheOperationForKey:(nullable NSString *)key done:(nullable SDCacheQueryCompletedBlock)doneBlock;</span><br><span class="line"></span><br><span class="line">//异步的方式来获取硬盘缓存的图片</span><br><span class="line">- (nullable NSOperation *)queryCacheOperationForKey:(nullable NSString *)key options:(SDImageCacheOptions)options done:(nullable SDCacheQueryCompletedBlock)doneBlock;</span><br><span class="line"></span><br><span class="line">//同步的方式来获取内存缓存的图片</span><br><span class="line">- (nullable UIImage *)imageFromMemoryCacheForKey:(nullable NSString *)key;</span><br><span class="line"></span><br><span class="line">/同步的方式获取硬盘缓存的图片</span><br><span class="line">- (nullable UIImage *)imageFromDiskCacheForKey:(nullable NSString *)key;</span><br><span class="line"></span><br><span class="line">//同步的方式，先查询内存中有没有缓存的图片，如果没有再查询硬盘中有没有缓存的图片</span><br><span class="line">- (nullable UIImage *)imageFromCacheForKey:(nullable NSString *)key;</span><br><span class="line"></span><br><span class="line">#pragma mark - Remove Ops</span><br><span class="line"></span><br><span class="line">//异步的方式移除缓存中的图片，包括内存和硬盘</span><br><span class="line">- (void)removeImageForKey:(nullable NSString *)key withCompletion:(nullable SDWebImageNoParamsBlock)completion;</span><br><span class="line"></span><br><span class="line">//异步的方式移除缓存中的图片，包括内存和硬盘(可选，fromDisk为YES移除硬盘缓存)</span><br><span class="line">- (void)removeImageForKey:(nullable NSString *)key fromDisk:(BOOL)fromDisk withCompletion:(nullable SDWebImageNoParamsBlock)completion;</span><br><span class="line"></span><br><span class="line">#pragma mark - Cache clean Ops</span><br><span class="line"></span><br><span class="line">//清除内存缓存</span><br><span class="line">- (void)clearMemory;</span><br><span class="line"></span><br><span class="line">//异步方式清除硬盘缓存</span><br><span class="line">- (void)clearDiskOnCompletion:(nullable SDWebImageNoParamsBlock)completion;</span><br><span class="line"></span><br><span class="line">//异步方式清除过期的图片</span><br><span class="line">- (void)deleteOldFilesWithCompletionBlock:(nullable SDWebImageNoParamsBlock)completionBlock;</span><br><span class="line"></span><br><span class="line">#pragma mark - Cache Info</span><br><span class="line"></span><br><span class="line">//同步方式计算缓存目录的大小</span><br><span class="line">- (NSUInteger)getSize;</span><br><span class="line"></span><br><span class="line">//同步方式计算缓存的图片数量</span><br><span class="line">- (NSUInteger)getDiskCount;</span><br><span class="line"></span><br><span class="line">//异步的方式获取缓存图片数量和大小</span><br><span class="line">- (void)calculateSizeWithCompletionBlock:(nullable SDWebImageCalculateSizeBlock)completionBlock;</span><br><span class="line"></span><br><span class="line">#pragma mark - Cache Paths</span><br><span class="line"></span><br><span class="line">//指定key，获取图片的缓存路径</span><br><span class="line">- (nullable NSString *)cachePathForKey:(nullable NSString *)key inPath:(nonnull NSString *)path;</span><br><span class="line"></span><br><span class="line">//指定key，获取图片默认的缓存路径</span><br><span class="line">- (nullable NSString *)defaultCachePathForKey:(nullable NSString *)key;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<h4 id="SDImageCache-m"><a href="#SDImageCache-m" class="headerlink" title="SDImageCache.m"></a>SDImageCache.m</h4><p>SDMemoryCache继承自NSCache。NSCache可以设置totalCostLimit，来限制缓存的总成本消耗，所以我们再添加缓存的时候需要</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)setObject:(ObjectType)obj forKey:(KeyType)key cost:(NSUInteger)g;</span><br></pre></td></tr></table></figure>
<p>通过cost来指定缓存对象消耗的成本。</p>
<h6 id="SDImageCache如何计算图片消耗的成本？"><a href="#SDImageCache如何计算图片消耗的成本？" class="headerlink" title="SDImageCache如何计算图片消耗的成本？"></a>SDImageCache如何计算图片消耗的成本？</h6><p>SDImageCache把图片的像素点来计算图片的消耗成本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FOUNDATION_STATIC_INLINE NSUInteger SDCacheCostForImage(UIImage *image) &#123;</span><br><span class="line">#if SD_MAC</span><br><span class="line">    return image.size.height * image.size.width;</span><br><span class="line">#elif SD_UIKIT || SD_WATCH</span><br><span class="line">    return image.size.height * image.size.width * image.scale * image.scale;</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="SDMemoryCache"><a href="#SDMemoryCache" class="headerlink" title="SDMemoryCache"></a>SDMemoryCache</h5><p>解析以注释的形式在代码中体现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">@interface SDMemoryCache &lt;KeyType, ObjectType&gt; ()</span><br><span class="line"></span><br><span class="line">@property (nonatomic, strong, nonnull) SDImageCacheConfig *config;</span><br><span class="line">//弱引用表</span><br><span class="line">@property (nonatomic, strong, nonnull) NSMapTable&lt;KeyType, ObjectType&gt; *weakCache; </span><br><span class="line">//多线程锁保证多线程环境下weakCache数据安全</span><br><span class="line">@property (nonatomic, strong, nonnull) dispatch_semaphore_t weakCacheLock; </span><br><span class="line"></span><br><span class="line">- (instancetype)init NS_UNAVAILABLE;</span><br><span class="line">- (instancetype)initWithConfig:(nonnull SDImageCacheConfig *)config;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation SDMemoryCache</span><br><span class="line"></span><br><span class="line">- (void)dealloc &#123;</span><br><span class="line">    [[NSNotificationCenter defaultCenter] removeObserver:self name:UIApplicationDidReceiveMemoryWarningNotification object:nil];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithConfig:(SDImageCacheConfig *)config &#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">    	//初始化弱引用表，当收到内存警告，内存缓存虽然被清理，但是有些图片已经被其他对象强引用着，这时weakCache维持这些图片的弱引用。如果需要获取这些图片就不用去硬盘获取了</span><br><span class="line">    	//NSPointerFunctionsWeakMemory，对值进行弱引用，不会对引用计数+1</span><br><span class="line">        self.weakCache = [[NSMapTable alloc] initWithKeyOptions:NSPointerFunctionsStrongMemory valueOptions:NSPointerFunctionsWeakMemory capacity:0];</span><br><span class="line">        self.weakCacheLock = dispatch_semaphore_create(1);</span><br><span class="line">        self.config = config;</span><br><span class="line">        //监听内存警告通知</span><br><span class="line">        [[NSNotificationCenter defaultCenter] addObserver:self</span><br><span class="line">                                                 selector:@selector(didReceiveMemoryWarning:)</span><br><span class="line">                                                     name:UIApplicationDidReceiveMemoryWarningNotification</span><br><span class="line">                                                   object:nil];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)didReceiveMemoryWarning:(NSNotification *)notification &#123;</span><br><span class="line">    //当收到内存警告通知，移除内存中缓存的图片</span><br><span class="line">    //同时保留weakCache，维持对被强引用着的图片的访问</span><br><span class="line">    [super removeAllObjects];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setObject:(id)obj forKey:(id)key cost:(NSUInteger)g &#123;</span><br><span class="line">    [super setObject:obj forKey:key cost:g];</span><br><span class="line">    if (!self.config.shouldUseWeakMemoryCache) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (key &amp;&amp; obj) &#123;</span><br><span class="line">        // 存入弱引用表</span><br><span class="line">        LOCK(self.weakCacheLock);</span><br><span class="line">        [self.weakCache setObject:obj forKey:key];</span><br><span class="line">        UNLOCK(self.weakCacheLock);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (id)objectForKey:(id)key &#123;</span><br><span class="line">    id obj = [super objectForKey:key];</span><br><span class="line">    if (!self.config.shouldUseWeakMemoryCache) &#123;</span><br><span class="line">        return obj;</span><br><span class="line">    &#125;</span><br><span class="line">    if (key &amp;&amp; !obj) &#123;</span><br><span class="line">        LOCK(self.weakCacheLock);</span><br><span class="line">        obj = [self.weakCache objectForKey:key];</span><br><span class="line">        UNLOCK(self.weakCacheLock);</span><br><span class="line">        if (obj) &#123;</span><br><span class="line">            // 把通过弱引用表获取的图片添加到内存缓存中</span><br><span class="line">            NSUInteger cost = 0;</span><br><span class="line">            if ([obj isKindOfClass:[UIImage class]]) &#123;</span><br><span class="line">                cost = SDCacheCostForImage(obj);</span><br><span class="line">            &#125;</span><br><span class="line">            [super setObject:obj forKey:key cost:cost];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)removeObjectForKey:(id)key &#123;</span><br><span class="line">    [super removeObjectForKey:key];</span><br><span class="line">    if (!self.config.shouldUseWeakMemoryCache) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (key) &#123;</span><br><span class="line">        // 从weakCache移除</span><br><span class="line">        LOCK(self.weakCacheLock);</span><br><span class="line">        [self.weakCache removeObjectForKey:key];</span><br><span class="line">        UNLOCK(self.weakCacheLock);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)removeAllObjects &#123;</span><br><span class="line">    [super removeAllObjects];</span><br><span class="line">    if (!self.config.shouldUseWeakMemoryCache) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // 清除弱引用表</span><br><span class="line">    LOCK(self.weakCacheLock);</span><br><span class="line">    [self.weakCache removeAllObjects];</span><br><span class="line">    UNLOCK(self.weakCacheLock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#else</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithConfig:(SDImageCacheConfig *)config &#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>SDImageCache私有拓展的属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//内存缓存管理实例</span><br><span class="line">@property (strong, nonatomic, nonnull) SDMemoryCache *memCache;</span><br><span class="line">//硬盘缓存路径</span><br><span class="line">@property (strong, nonatomic, nonnull) NSString *diskCachePath;</span><br><span class="line">//读取缓存图片额外的路径，以通过addReadOnlyCachePath:这个方法往里边添加路径</span><br><span class="line">@property (strong, nonatomic, nullable) NSMutableArray&lt;NSString *&gt; *customPaths;</span><br><span class="line">//访问操作硬盘缓存时用到的串行队列</span><br><span class="line">@property (strong, nonatomic, nullable) dispatch_queue_t ioQueue;</span><br><span class="line">//存储图片到硬盘的文件管理者</span><br><span class="line">@property (strong, nonatomic, nonnull) NSFileManager *fileManager;</span><br></pre></td></tr></table></figure>
<p>初始化函数最终都会调用</p>
<p>- (nonnull instancetype)initWithNamespace:(nonnull NSString *)ns</p>
<p>​                       diskCacheDirectory:(nonnull NSString *)directory</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">- (nonnull instancetype)initWithNamespace:(nonnull NSString *)ns</span><br><span class="line">                       diskCacheDirectory:(nonnull NSString *)directory &#123;</span><br><span class="line">    if ((self = [super init])) &#123;</span><br><span class="line">    	//初始化参数</span><br><span class="line">        NSString *fullNamespace = [@&quot;com.hackemist.SDWebImageCache.&quot; stringByAppendingString:ns];</span><br><span class="line">        _ioQueue = dispatch_queue_create(&quot;com.hackemist.SDWebImageCache&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">        _config = [[SDImageCacheConfig alloc] init];</span><br><span class="line">        _memCache = [[SDMemoryCache alloc] initWithConfig:_config];</span><br><span class="line">        _memCache.name = fullNamespace;</span><br><span class="line">        if (directory != nil) &#123;</span><br><span class="line">            _diskCachePath = [directory stringByAppendingPathComponent:fullNamespace];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            NSString *path = [self makeDiskCachePath:ns];</span><br><span class="line">            _diskCachePath = path;</span><br><span class="line">        &#125;</span><br><span class="line">        dispatch_sync(_ioQueue, ^&#123;</span><br><span class="line">            self.fileManager = [NSFileManager new];</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">#if SD_UIKIT</span><br><span class="line">		//监听通知来清除过期的图片缓存数据</span><br><span class="line">        [[NSNotificationCenter defaultCenter] addObserver:self</span><br><span class="line">                                                 selector:@selector(deleteOldFiles)</span><br><span class="line">                                                     name:UIApplicationWillTerminateNotification</span><br><span class="line">                                                   object:nil];</span><br><span class="line">        [[NSNotificationCenter defaultCenter] addObserver:self</span><br><span class="line">                                                 selector:@selector(backgroundDeleteOldFiles)</span><br><span class="line">                                                     name:UIApplicationDidEnterBackgroundNotification</span><br><span class="line">                                                   object:nil];</span><br><span class="line">#endif</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>如果进入沙盒查看缓存的图片，可以发现文件名是用过md5的格式来命名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (nullable NSString *)cachedFileNameForKey:(nullable NSString *)key &#123;</span><br><span class="line">    const char *str = key.UTF8String;</span><br><span class="line">    if (str == NULL) &#123;</span><br><span class="line">        str = &quot;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    unsigned char r[CC_MD5_DIGEST_LENGTH];</span><br><span class="line">    //计算key的md5值</span><br><span class="line">    CC_MD5(str, (CC_LONG)strlen(str), r);</span><br><span class="line">    NSURL *keyURL = [NSURL URLWithString:key];</span><br><span class="line">    NSString *ext = keyURL ? keyURL.pathExtension : key.pathExtension;</span><br><span class="line">    //md5值拼接文件后缀</span><br><span class="line">    NSString *filename = [NSString stringWithFormat:@&quot;%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%@&quot;,</span><br><span class="line">                          r[0], r[1], r[2], r[3], r[4], r[5], r[6], r[7], r[8], r[9], r[10],</span><br><span class="line">                          r[11], r[12], r[13], r[14], r[15], ext.length == 0 ? @&quot;&quot; : [NSString stringWithFormat:@&quot;.%@&quot;, ext]];</span><br><span class="line">    return filename;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>异步缓存图片</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">- (void)storeImage:(nullable UIImage *)image</span><br><span class="line">         imageData:(nullable NSData *)imageData</span><br><span class="line">            forKey:(nullable NSString *)key</span><br><span class="line">            toDisk:(BOOL)toDisk</span><br><span class="line">        completion:(nullable SDWebImageNoParamsBlock)completionBlock &#123;</span><br><span class="line">    if (!image || !key) &#123;</span><br><span class="line">        if (completionBlock) &#123;</span><br><span class="line">            completionBlock();</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果允许内存缓存，先把图片缓存到内存</span><br><span class="line">    if (self.config.shouldCacheImagesInMemory) &#123;</span><br><span class="line">        NSUInteger cost = SDCacheCostForImage(image);</span><br><span class="line">        [self.memCache setObject:image forKey:key cost:cost];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (toDisk) &#123;</span><br><span class="line">        dispatch_async(self.ioQueue, ^&#123;</span><br><span class="line">        	//一般图片的大小都不会很小，对图片进行编码过程中也会产出一些开销不小的临时对象,在子线程中添加自动释放池，可以提前释放这些对象，缓解内存压力。</span><br><span class="line">            @autoreleasepool &#123;</span><br><span class="line">                NSData *data = imageData;</span><br><span class="line">                if (!data &amp;&amp; image) &#123;</span><br><span class="line">                    SDImageFormat format;</span><br><span class="line">                    if (SDCGImageRefContainsAlpha(image.CGImage)) &#123;</span><br><span class="line">                        format = SDImageFormatPNG;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        format = SDImageFormatJPEG;</span><br><span class="line">                    &#125;</span><br><span class="line">                    //把图片进行编码，得到可以存储的二进制数据</span><br><span class="line">                    data = [[SDWebImageCodersManager sharedInstance] encodedDataWithImage:image format:format];</span><br><span class="line">                &#125;</span><br><span class="line">                [self _storeImageDataToDisk:data forKey:key];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            if (completionBlock) &#123;</span><br><span class="line">                dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                    completionBlock();</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (completionBlock) &#123;</span><br><span class="line">            completionBlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>内部方法：使用的把图片二进制数据存入硬盘</p>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (void)_storeImageDataToDisk:(nullable NSData *)imageData forKey:(nullable NSString *)key &#123;</span><br><span class="line">    if (!imageData || !key) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (![self.fileManager fileExistsAtPath:_diskCachePath]) &#123;</span><br><span class="line">    	//如果还没有缓存目录，通过fileManager生成缓存目录</span><br><span class="line">        [self.fileManager createDirectoryAtPath:_diskCachePath withIntermediateDirectories:YES attributes:nil error:NULL];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 获取缓存的文件名,对key进行md5加密</span><br><span class="line">    NSString *cachePathForKey = [self defaultCachePathForKey:key];</span><br><span class="line">    NSURL *fileURL = [NSURL fileURLWithPath:cachePathForKey];</span><br><span class="line">    //保存到硬盘</span><br><span class="line">    [imageData writeToURL:fileURL options:self.config.diskCacheWritingOptions error:nil];</span><br><span class="line">    </span><br><span class="line">    // 禁止iCloud备份</span><br><span class="line">    if (self.config.shouldDisableiCloud) &#123;</span><br><span class="line">        [fileURL setResourceValue:@YES forKey:NSURLIsExcludedFromBackupKey error:nil];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>因为从硬盘查询是否有缓存图片会是一个比较耗时的操作，所以SDImageCache还提供了异步的方式，通过block回调查询结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (void)diskImageExistsWithKey:(nullable NSString *)key completion:(nullable SDWebImageCheckCacheCompletionBlock)completionBlock &#123;</span><br><span class="line">    dispatch_async(self.ioQueue, ^&#123;</span><br><span class="line">        BOOL exists = [self _diskImageDataExistsWithKey:key];</span><br><span class="line">        if (completionBlock) &#123;</span><br><span class="line">            dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                completionBlock(exists);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>在命名空间指定的目录和自定义只读路径中查询获取图片</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">- (nullable NSData *)diskImageDataBySearchingAllPathsForKey:(nullable NSString *)key &#123;</span><br><span class="line">    NSString *defaultPath = [self defaultCachePathForKey:key];</span><br><span class="line">    //在缓存目录查找获取图片</span><br><span class="line">    NSData *data = [NSData dataWithContentsOfFile:defaultPath options:self.config.diskCacheReadingOptions error:nil];</span><br><span class="line">    if (data) &#123;</span><br><span class="line">        return data;</span><br><span class="line">    &#125;</span><br><span class="line">    data = [NSData dataWithContentsOfFile:defaultPath.stringByDeletingPathExtension options:self.config.diskCacheReadingOptions error:nil];</span><br><span class="line">    if (data) &#123;</span><br><span class="line">        return data;</span><br><span class="line">    &#125;</span><br><span class="line">	//在自定义的只读路径中查询获取图片</span><br><span class="line">    NSArray&lt;NSString *&gt; *customPaths = [self.customPaths copy];</span><br><span class="line">    for (NSString *path in customPaths) &#123;</span><br><span class="line">        NSString *filePath = [self cachePathForKey:key inPath:path];</span><br><span class="line">        NSData *imageData = [NSData dataWithContentsOfFile:filePath options:self.config.diskCacheReadingOptions error:nil];</span><br><span class="line">        if (imageData) &#123;</span><br><span class="line">            return imageData;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        imageData = [NSData dataWithContentsOfFile:filePath.stringByDeletingPathExtension options:self.config.diskCacheReadingOptions error:nil];</span><br><span class="line">        if (imageData) &#123;</span><br><span class="line">            return imageData;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>从硬盘中获取图片(同步的方式获取)，查询到图片后shouldCacheImagesInMemory=YES同步保存到内存缓存中，下次再获取的时候直接从内存中获取</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">- (nullable UIImage *)imageFromDiskCacheForKey:(nullable NSString *)key &#123;</span><br><span class="line">    UIImage *diskImage = [self diskImageForKey:key];</span><br><span class="line">    if (diskImage &amp;&amp; self.config.shouldCacheImagesInMemory) &#123;</span><br><span class="line">        NSUInteger cost = SDCacheCostForImage(diskImage);</span><br><span class="line">        //同步缓存到内存</span><br><span class="line">        [self.memCache setObject:diskImage forKey:key cost:cost];</span><br><span class="line">    &#125;</span><br><span class="line">    return diskImage;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (nullable UIImage *)imageFromCacheForKey:(nullable NSString *)key &#123;</span><br><span class="line">	//先从内存中尝试获取缓存图片</span><br><span class="line">    UIImage *image = [self imageFromMemoryCacheForKey:key];</span><br><span class="line">    if (image) &#123;</span><br><span class="line">        return image;</span><br><span class="line">    &#125;</span><br><span class="line">    //内存中没有缓存，尝试从硬盘中获取 imageFromDiskCacheForKey 就是上面的方法</span><br><span class="line">    image = [self imageFromDiskCacheForKey:key];</span><br><span class="line">    return image;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (nullable UIImage *)diskImageForKey:(nullable NSString *)key &#123;</span><br><span class="line">    NSData *data = [self diskImageDataForKey:key];</span><br><span class="line">    return [self diskImageForKey:key data:data];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (nullable UIImage *)diskImageForKey:(nullable NSString *)key data:(nullable NSData *)data &#123;</span><br><span class="line">    return [self diskImageForKey:key data:data options:0];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (nullable UIImage *)diskImageForKey:(nullable NSString *)key data:(nullable NSData *)data options:(SDImageCacheOptions)options &#123;</span><br><span class="line">    if (data) &#123;</span><br><span class="line">    	//实例化一个uiimage，此时的uiimage还没有进行解码</span><br><span class="line">        UIImage *image = [[SDWebImageCodersManager sharedInstance] decodedImageWithData:data];</span><br><span class="line">        image = [self scaledImageForKey:key image:image];</span><br><span class="line">        if (self.config.shouldDecompressImages) &#123;</span><br><span class="line">        	//对image进行预解码</span><br><span class="line">            BOOL shouldScaleDown = options &amp; SDImageCacheScaleDownLargeImages;</span><br><span class="line">            image = [[SDWebImageCodersManager sharedInstance] decompressedImageWithImage:image data:&amp;data options:@&#123;SDWebImageCoderScaleDownLargeImagesKey: @(shouldScaleDown)&#125;];</span><br><span class="line">        &#125;</span><br><span class="line">        return image;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>异步的方式获取硬盘缓存图片</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">- (nullable NSOperation *)queryCacheOperationForKey:(nullable NSString *)key options:(SDImageCacheOptions)options done:(nullable SDCacheQueryCompletedBlock)doneBlock &#123;</span><br><span class="line">    if (!key) &#123;</span><br><span class="line">        if (doneBlock) &#123;</span><br><span class="line">            doneBlock(nil, nil, SDImageCacheTypeNone);</span><br><span class="line">        &#125;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 首先检查内存中是否有缓存的图片</span><br><span class="line">    UIImage *image = [self imageFromMemoryCacheForKey:key];</span><br><span class="line">    //当内存中有缓存，并且SDImageCacheQueryDataWhenInMemory(内存中有缓存仍然查询硬盘缓存)为false，立即返回内存缓存的图片</span><br><span class="line">    BOOL shouldQueryMemoryOnly = (image &amp;&amp; !(options &amp; SDImageCacheQueryDataWhenInMemory));</span><br><span class="line">    if (shouldQueryMemoryOnly) &#123;</span><br><span class="line">        if (doneBlock) &#123;</span><br><span class="line">            doneBlock(image, nil, SDImageCacheTypeMemory);</span><br><span class="line">        &#125;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    NSOperation *operation = [NSOperation new];</span><br><span class="line">    void(^queryDiskBlock)(void) =  ^&#123;</span><br><span class="line">        if (operation.isCancelled) &#123;</span><br><span class="line">            // operation取消，直接返回</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        @autoreleasepool &#123;</span><br><span class="line">        	//从硬盘获取缓存</span><br><span class="line">            NSData *diskData = [self diskImageDataBySearchingAllPathsForKey:key];</span><br><span class="line">            UIImage *diskImage;</span><br><span class="line">            SDImageCacheType cacheType = SDImageCacheTypeDisk;</span><br><span class="line">            if (image) &#123;</span><br><span class="line">                // 如果内存本来就有缓存图片，则把内存缓存的图片返回，可以省去对图片再一次解码</span><br><span class="line">                diskImage = image;</span><br><span class="line">                cacheType = SDImageCacheTypeMemory;</span><br><span class="line">            &#125; else if (diskData) &#123;</span><br><span class="line">                // 如果内存没有缓存的图片，那么从硬盘得到的是图片压缩的二进制数据，使用前需要先解码</span><br><span class="line">                diskImage = [self diskImageForKey:key data:diskData options:options];</span><br><span class="line">                if (diskImage &amp;&amp; self.config.shouldCacheImagesInMemory) &#123;</span><br><span class="line">                	//同步保存到内存缓存中</span><br><span class="line">                    NSUInteger cost = SDCacheCostForImage(diskImage);</span><br><span class="line">                    [self.memCache setObject:diskImage forKey:key cost:cost];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            if (doneBlock) &#123;</span><br><span class="line">                if (options &amp; SDImageCacheQueryDiskSync) &#123;</span><br><span class="line">                    doneBlock(diskImage, diskData, cacheType);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                        doneBlock(diskImage, diskData, cacheType);</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    if (options &amp; SDImageCacheQueryDiskSync) &#123;</span><br><span class="line">        queryDiskBlock();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        dispatch_async(self.ioQueue, queryDiskBlock);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return operation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>从缓存中移除图片</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">- (void)removeImageForKey:(nullable NSString *)key fromDisk:(BOOL)fromDisk withCompletion:(nullable SDWebImageNoParamsBlock)completion &#123;</span><br><span class="line">    if (key == nil) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (self.config.shouldCacheImagesInMemory) &#123;</span><br><span class="line">        [self.memCache removeObjectForKey:key];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (fromDisk) &#123;</span><br><span class="line">        dispatch_async(self.ioQueue, ^&#123;</span><br><span class="line">            [self.fileManager removeItemAtPath:[self defaultCachePathForKey:key] error:nil];</span><br><span class="line">            </span><br><span class="line">            if (completion) &#123;</span><br><span class="line">                dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                    completion();</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; else if (completion)&#123;</span><br><span class="line">        completion();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>清空缓存</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//清空内存缓存</span><br><span class="line">- (void)clearMemory &#123;</span><br><span class="line">    [self.memCache removeAllObjects];</span><br><span class="line">&#125;</span><br><span class="line">//清空硬盘缓存</span><br><span class="line">- (void)clearDiskOnCompletion:(nullable SDWebImageNoParamsBlock)completion &#123;</span><br><span class="line">    dispatch_async(self.ioQueue, ^&#123;</span><br><span class="line">        [self.fileManager removeItemAtPath:self.diskCachePath error:nil];</span><br><span class="line">        [self.fileManager createDirectoryAtPath:self.diskCachePath</span><br><span class="line">                withIntermediateDirectories:YES</span><br><span class="line">                                 attributes:nil</span><br><span class="line">                                      error:NULL];</span><br><span class="line"></span><br><span class="line">        if (completion) &#123;</span><br><span class="line">            dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                completion();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>SDImageCache在app退出，或者进入到后台，都会对缓存目录下的图片进行清理，把过期的图片移除掉</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">- (void)deleteOldFilesWithCompletionBlock:(nullable SDWebImageNoParamsBlock)completionBlock &#123;</span><br><span class="line">    dispatch_async(self.ioQueue, ^&#123;</span><br><span class="line">        NSURL *diskCacheURL = [NSURL fileURLWithPath:self.diskCachePath isDirectory:YES];</span><br><span class="line"></span><br><span class="line">        NSURLResourceKey cacheContentDateKey = NSURLContentModificationDateKey;</span><br><span class="line">        switch (self.config.diskCacheExpireType) &#123;</span><br><span class="line">            case SDImageCacheConfigExpireTypeAccessDate:</span><br><span class="line">            	//最近访问的时间到现在作为过期时间</span><br><span class="line">                cacheContentDateKey = NSURLContentAccessDateKey;</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            case SDImageCacheConfigExpireTypeModificationDate:</span><br><span class="line">            	//最近修改的时间到现在作为过期时间</span><br><span class="line">                cacheContentDateKey = NSURLContentModificationDateKey;</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            default:</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        NSArray&lt;NSString *&gt; *resourceKeys = @[NSURLIsDirectoryKey, cacheContentDateKey, NSURLTotalFileAllocatedSizeKey];</span><br><span class="line"></span><br><span class="line">        // This enumerator prefetches useful properties for our cache files.</span><br><span class="line">        NSDirectoryEnumerator *fileEnumerator = [self.fileManager enumeratorAtURL:diskCacheURL</span><br><span class="line">                                                   includingPropertiesForKeys:resourceKeys</span><br><span class="line">                                                                      options:NSDirectoryEnumerationSkipsHiddenFiles</span><br><span class="line">                                                                 errorHandler:NULL];</span><br><span class="line">		//通过SDImageCacheConfig.maxCacheAge计算出该被移除的缓存时间边界值</span><br><span class="line">        NSDate *expirationDate = [NSDate dateWithTimeIntervalSinceNow:-self.config.maxCacheAge];</span><br><span class="line">        //用来保存未过期的缓存图片</span><br><span class="line">        NSMutableDictionary&lt;NSURL *, NSDictionary&lt;NSString *, id&gt; *&gt; *cacheFiles = [NSMutableDictionary dictionary];</span><br><span class="line">        //用来记录当前缓存大小</span><br><span class="line">        NSUInteger currentCacheSize = 0;</span><br><span class="line">        //用来保存过期图片的url</span><br><span class="line">        NSMutableArray&lt;NSURL *&gt; *urlsToDelete = [[NSMutableArray alloc] init];</span><br><span class="line">        </span><br><span class="line">        // 在缓存目录下遍历图片，把过期的缓存图片移除掉，把未过期的图片添加到cacheFiles来进行下一步的清理工作(以size作为清理标准)</span><br><span class="line">        for (NSURL *fileURL in fileEnumerator) &#123;</span><br><span class="line">            NSError *error;</span><br><span class="line">            NSDictionary&lt;NSString *, id&gt; *resourceValues = [fileURL resourceValuesForKeys:resourceKeys error:&amp;error];</span><br><span class="line"></span><br><span class="line">            // 跳过文件夹</span><br><span class="line">            if (error || !resourceValues || [resourceValues[NSURLIsDirectoryKey] boolValue]) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 移除过期的图片</span><br><span class="line">            NSDate *modifiedDate = resourceValues[cacheContentDateKey];</span><br><span class="line">            //laterDate:返回的是较晚的时间，如果修改时间比上面计算的缓存时间边界值还早，就说明该缓存图片已经过期了，添加到urlsToDelete等待删除</span><br><span class="line">            if ([[modifiedDate laterDate:expirationDate] isEqualToDate:expirationDate]) &#123;</span><br><span class="line">                [urlsToDelete addObject:fileURL];</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            NSNumber *totalAllocatedSize = resourceValues[NSURLTotalFileAllocatedSizeKey];</span><br><span class="line">            currentCacheSize += totalAllocatedSize.unsignedIntegerValue;</span><br><span class="line">            cacheFiles[fileURL] = resourceValues;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //循环遍历，移除过期的图片</span><br><span class="line">        for (NSURL *fileURL in urlsToDelete) &#123;</span><br><span class="line">            [self.fileManager removeItemAtURL:fileURL error:nil];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 如果我们设置了SDImageCacheConfig.maxCacheSize，并且当前缓存目录的大小大于config.maxCacheSize，需要对缓存目录进行二次清理，直到缓存目录大小 &lt;= config.maxCacheSize/2</span><br><span class="line">        if (self.config.maxCacheSize &gt; 0 &amp;&amp; currentCacheSize &gt; self.config.maxCacheSize) &#123;</span><br><span class="line">            const NSUInteger desiredCacheSize = self.config.maxCacheSize / 2;</span><br><span class="line">            //把缓存的图片从新排序，较早的图片放在前面</span><br><span class="line">            NSArray&lt;NSURL *&gt; *sortedFiles = [cacheFiles keysSortedByValueWithOptions:NSSortConcurrent</span><br><span class="line">                                                                     usingComparator:^NSComparisonResult(id obj1, id obj2) &#123;</span><br><span class="line">                                                                         return [obj1[NSURLContentModificationDateKey] compare:obj2[NSURLContentModificationDateKey]];</span><br><span class="line">                                                                     &#125;];</span><br><span class="line"></span><br><span class="line">            // 删除图片知道缓存目录大小 &lt;= config.maxCacheSize/2</span><br><span class="line">            for (NSURL *fileURL in sortedFiles) &#123;</span><br><span class="line">                if ([self.fileManager removeItemAtURL:fileURL error:nil]) &#123;</span><br><span class="line">                    NSDictionary&lt;NSString *, id&gt; *resourceValues = cacheFiles[fileURL];</span><br><span class="line">                    NSNumber *totalAllocatedSize = resourceValues[NSURLTotalFileAllocatedSizeKey];</span><br><span class="line">                    currentCacheSize -= totalAllocatedSize.unsignedIntegerValue;</span><br><span class="line">                    if (currentCacheSize &lt; desiredCacheSize) &#123;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (completionBlock) &#123;</span><br><span class="line">            dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                completionBlock();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>同步的方式获取缓存目录的大小和文件数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (NSUInteger)getSize &#123;</span><br><span class="line">    __block NSUInteger size = 0;</span><br><span class="line">    dispatch_sync(self.ioQueue, ^&#123;</span><br><span class="line">        NSDirectoryEnumerator *fileEnumerator = [self.fileManager enumeratorAtPath:self.diskCachePath];</span><br><span class="line">        for (NSString *fileName in fileEnumerator) &#123;</span><br><span class="line">            NSString *filePath = [self.diskCachePath stringByAppendingPathComponent:fileName];</span><br><span class="line">            NSDictionary&lt;NSString *, id&gt; *attrs = [self.fileManager attributesOfItemAtPath:filePath error:nil];</span><br><span class="line">            size += [attrs fileSize];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    return size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSUInteger)getDiskCount &#123;</span><br><span class="line">    __block NSUInteger count = 0;</span><br><span class="line">    dispatch_sync(self.ioQueue, ^&#123;</span><br><span class="line">        NSDirectoryEnumerator *fileEnumerator = [self.fileManager enumeratorAtPath:self.diskCachePath];</span><br><span class="line">        count = fileEnumerator.allObjects.count;</span><br><span class="line">    &#125;);</span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>异步的方式获取缓存目录的大小和文件数，block回调</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">- (void)calculateSizeWithCompletionBlock:(nullable SDWebImageCalculateSizeBlock)completionBlock &#123;</span><br><span class="line">    NSURL *diskCacheURL = [NSURL fileURLWithPath:self.diskCachePath isDirectory:YES];</span><br><span class="line"></span><br><span class="line">    dispatch_async(self.ioQueue, ^&#123;</span><br><span class="line">        NSUInteger fileCount = 0;</span><br><span class="line">        NSUInteger totalSize = 0;</span><br><span class="line"></span><br><span class="line">        NSDirectoryEnumerator *fileEnumerator = [self.fileManager enumeratorAtURL:diskCacheURL</span><br><span class="line">                                                   includingPropertiesForKeys:@[NSFileSize]</span><br><span class="line">                                                                      options:NSDirectoryEnumerationSkipsHiddenFiles</span><br><span class="line">                                                                 errorHandler:NULL];</span><br><span class="line"></span><br><span class="line">        for (NSURL *fileURL in fileEnumerator) &#123;</span><br><span class="line">            NSNumber *fileSize;</span><br><span class="line">            [fileURL getResourceValue:&amp;fileSize forKey:NSURLFileSizeKey error:NULL];</span><br><span class="line">            totalSize += fileSize.unsignedIntegerValue;</span><br><span class="line">            fileCount += 1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (completionBlock) &#123;</span><br><span class="line">            dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                completionBlock(fileCount, totalSize);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/06/iOS多线程之：GCD/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DevHuangjb">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="黄锦标的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/06/iOS多线程之：GCD/" itemprop="url">iOS多线程之：GCD</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-01-06T13:47:46+08:00">
                2019-01-06
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>我个人在开发中，遇到并发的操作，比较习惯用GCD来实现。原因很简单，高效！方便！</p>
<h6 id="什么是GCD"><a href="#什么是GCD" class="headerlink" title="什么是GCD?"></a>什么是GCD?</h6><blockquote>
<p>百度百科：Grand Central Dispatch (GCD)是Apple开发的一个多核编程的较新的解决方法。它主要用于优化应用程序以支持多核处理器以及其他对称多处理系统。它是一个在线程池模式的基础上执行的并行任务。</p>
</blockquote>
<p>从字面上来看，GCD意思是“伟大的中枢调度器”。是纯C语言的API,提供了非常强大的函数。</p>
<h6 id="GCD的优势"><a href="#GCD的优势" class="headerlink" title="GCD的优势"></a>GCD的优势</h6><ul>
<li>GCD是苹果为多核运算提出的解决方案，可以更好的利用CPU的多核优势</li>
<li>GCD会自动管理线程的生命周期(创建线程，调度任务，销毁线程)</li>
<li>方便的使用API，程序员只需要专注于要执行的任务</li>
</ul>
<h6 id="任务和队列"><a href="#任务和队列" class="headerlink" title="任务和队列"></a>任务和队列</h6><p>GCD开发中，两个很重要的概念就是任务和队列，核心就是把要执行的任务添加到队列里面</p>
<p>队列：用于管理任务的数据结构，队列遵循严格的FIFO原则，即先添加的任务先执行，后添加的任务后执行。</p>
<ul>
<li>串行队列：只会开辟一条子线程，队列上面的任务在这条线程上面一个一个依次的执行</li>
<li>并行队列：可以开辟多条线程，并行的执行队列上面的任务。</li>
</ul>
<p><strong>主队列：</strong>主队列是一种特殊的串行队列，所有放在主队列上面的任务都会在主线程当中执行。所以，主要用于操作UI元素的任务。使用dispatch_get_main_queue()来获取主队列</p>
<p><strong>全局队列：</strong>苹果默认创建的全局的并发队列。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">获取全局队列：dispatch_get_global_queue(long identifier, unsigned long flags );</span><br><span class="line">identifier：为队列指定的优先级</span><br><span class="line">flags：保留参数，必须传0，传其他值返回的nil。</span><br><span class="line">* iOS8后，苹果推出并推荐使用qos_class来指定全局队列的优先级</span><br><span class="line">* 以下优先级依次降低</span><br><span class="line">*  - QOS_CLASS_USER_INTERACTIVE</span><br><span class="line">*  - QOS_CLASS_USER_INITIATED</span><br><span class="line">*  - QOS_CLASS_DEFAULT</span><br><span class="line">*  - QOS_CLASS_UTILITY</span><br><span class="line">*  - QOS_CLASS_BACKGROUND</span><br><span class="line">*</span><br><span class="line">* 仍然可以使用priority来指定全局队列的优先级,priority和qos_class的映射关系如下：</span><br><span class="line">*  - DISPATCH_QUEUE_PRIORITY_HIGH:         QOS_CLASS_USER_INITIATED</span><br><span class="line">*  - DISPATCH_QUEUE_PRIORITY_DEFAULT:      QOS_CLASS_DEFAULT</span><br><span class="line">*  - DISPATCH_QUEUE_PRIORITY_LOW:          QOS_CLASS_UTILITY</span><br><span class="line">*  - DISPATCH_QUEUE_PRIORITY_BACKGROUND:   QOS_CLASS_BACKGROUND</span><br></pre></td></tr></table></figure>
<p>任务：就是我们要执行的操作。</p>
<p>任务执行的两种方式：</p>
<ul>
<li><p>同步执行：</p>
<ul>
<li>dispatch_sync同步的添加任务到队列中，队列中后面的任务必须等到同步执行的任务执行结束后才能执行；</li>
<li>不会开辟子线程，任务是在当前线程执行的</li>
</ul>
</li>
<li><p>异步执行：</p>
<ul>
<li><p>dispatch_asyn异步的添加任务到队列中，队列中后面的任务不用等到异步执行的任务结束就能执行。</p>
</li>
<li><p>具备开启子线程执行任务的能力</p>
</li>
<li><p>异步执行具备开启线程的能力，但不一定都开启子线程。在主队列不允许开新线程。</p>
</li>
</ul>
</li>
</ul>
<h6 id="GCD的使用"><a href="#GCD的使用" class="headerlink" title="GCD的使用"></a>GCD的使用</h6><p>根据两种类型的队列和两种不同的执行方式，我们可以有四种组合来使用GCD</p>
<ul>
<li>在串行队列上面同步执行任务</li>
<li><p>在串行队列上面异步执行任务</p>
</li>
<li><p>在并发队列上面同步执行任务</p>
</li>
<li>在并发队列上面异步执行任务</li>
<li>在主队列上面同步执行任务</li>
<li>在主队列上面异步执行任务</li>
</ul>
<p>以下的测试方法都是在 <strong><em>主线程</em></strong> 执行：</p>
<ol>
<li><p>在串行队列上面同步执行任务：不开辟子线程，任务顺序一个一个在当前线程执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (void)sync_serial &#123;</span><br><span class="line">    dispatch_queue_t queue = dispatch_queue_create(NULL, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">        dispatch_sync(queue, ^&#123;</span><br><span class="line">            NSLog(@&quot;%@ %d&quot;, [NSThread currentThread], i);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">控制台输出：</span><br><span class="line">2019-01-06 15:38:49.235601+0800 GCD_Demo[1665:267519] &lt;NSThread: 0x6000000a5400&gt;&#123;number = 1, name = main&#125; 0</span><br><span class="line">2019-01-06 15:38:49.235734+0800 GCD_Demo[1665:267519] &lt;NSThread: 0x6000000a5400&gt;&#123;number = 1, name = main&#125; 1</span><br><span class="line">2019-01-06 15:38:49.235838+0800 GCD_Demo[1665:267519] &lt;NSThread: 0x6000000a5400&gt;&#123;number = 1, name = main&#125; 2</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="2">
<li><p>在串行队列上面异步执行任务：只会开辟一条子线程，任务在子线程依次执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (void)async_serial &#123;</span><br><span class="line">    dispatch_queue_t queue = dispatch_queue_create(NULL, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">        dispatch_async(queue, ^&#123;</span><br><span class="line">            NSLog(@&quot;%@ %d&quot;, [NSThread currentThread], i);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">控制台输出：</span><br><span class="line">2019-01-06 15:34:52.334973+0800 GCD_Demo[1594:253049] &lt;NSThread: 0x600003ce1f40&gt;&#123;number = 3, name = (null)&#125; 0</span><br><span class="line">2019-01-06 15:34:52.335465+0800 GCD_Demo[1594:253049] &lt;NSThread: 0x600003ce1f40&gt;&#123;number = 3, name = (null)&#125; 1</span><br><span class="line">2019-01-06 15:34:52.335570+0800 GCD_Demo[1594:253049] &lt;NSThread: 0x600003ce1f40&gt;&#123;number = 3, name = (null)&#125; 2</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="3">
<li>在并发队列上面同步执行任务：不开辟子线程，任务顺序一个一个在当前线程执行</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (void)sync_concurrent &#123;</span><br><span class="line">    dispatch_queue_t queue = dispatch_queue_create(NULL, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">        dispatch_sync(queue, ^&#123;</span><br><span class="line">            NSLog(@&quot;%@ %d&quot;, [NSThread currentThread], i);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">控制台输出：</span><br><span class="line">2019-01-06 15:36:59.044932+0800 GCD_Demo[1641:260902] &lt;NSThread: 0x600001e7e940&gt;&#123;number = 1, name = main&#125; 0</span><br><span class="line">2019-01-06 15:36:59.045100+0800 GCD_Demo[1641:260902] &lt;NSThread: 0x600001e7e940&gt;&#123;number = 1, name = main&#125; 1</span><br><span class="line">2019-01-06 15:36:59.045196+0800 GCD_Demo[1641:260902] &lt;NSThread: 0x600001e7e940&gt;&#123;number = 1, name = main&#125; 2</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>在并发队列上面异步执行任务：会开辟多个线程同时执行多个任务，具体开辟的线程数由内核决定</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (void)async_concurrent &#123;</span><br><span class="line">    dispatch_queue_t queue = dispatch_queue_create(NULL, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">        dispatch_async(queue, ^&#123;</span><br><span class="line">            NSLog(@&quot;%@ %d&quot;, [NSThread currentThread], i);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">控制台输出：</span><br><span class="line">2019-01-06 15:40:08.082757+0800 GCD_Demo[1695:274396] &lt;NSThread: 0x600000dba740&gt;&#123;number = 5, name = (null)&#125; 2</span><br><span class="line">2019-01-06 15:40:08.082768+0800 GCD_Demo[1695:274397] &lt;NSThread: 0x600000db6ac0&gt;&#123;number = 4, name = (null)&#125; 1</span><br><span class="line">2019-01-06 15:40:08.082775+0800 GCD_Demo[1695:274395] &lt;NSThread: 0x600000da2980&gt;&#123;number = 3, name = (null)&#125; 0</span><br></pre></td></tr></table></figure>
<ol start="5">
<li><p>在主队列上面异步执行任务：不开辟子线程，任务顺序一个一个在主线程执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (void)async_main_queue &#123;</span><br><span class="line">    dispatch_queue_t queue = dispatch_get_main_queue();</span><br><span class="line">    for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">        dispatch_async(queue, ^&#123;</span><br><span class="line">            NSLog(@&quot;%@ %d&quot;, [NSThread currentThread], i);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">控制台输出：</span><br><span class="line">2019-01-06 15:46:01.790810+0800 GCD_Demo[1797:294279] &lt;NSThread: 0x600002104dc0&gt;&#123;number = 1, name = main&#125; 0</span><br><span class="line">2019-01-06 15:46:01.790974+0800 GCD_Demo[1797:294279] &lt;NSThread: 0x600002104dc0&gt;&#123;number = 1, name = main&#125; 1</span><br><span class="line">2019-01-06 15:46:01.791075+0800 GCD_Demo[1797:294279] &lt;NSThread: 0x600002104dc0&gt;&#123;number = 1, name = main&#125; 2</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="6">
<li><p>在主队列上面同步执行任务：会出现死锁的情况</p>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (void)sync_main_queue &#123;</span><br><span class="line">    dispatch_queue_t queue = dispatch_get_main_queue();</span><br><span class="line">    for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">        dispatch_sync(queue, ^&#123;</span><br><span class="line">            NSLog(@&quot;%@ %d&quot;, [NSThread currentThread], i);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">控制台没有输出，程序crash</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>全局队列属于并发队列，使用起来和并发队列没什么差别，这里不再另行讨论</p>
<h6 id="关于在主队列上面同步执行任务出现死锁的讨论"><a href="#关于在主队列上面同步执行任务出现死锁的讨论" class="headerlink" title="关于在主队列上面同步执行任务出现死锁的讨论"></a>关于在主队列上面同步执行任务出现死锁的讨论</h6><p>有的同学可能会困惑，上面讨论的GCD六种使用方式中，为什么方式6会出现死锁而方式1不会呢？</p>
<p>之所以会出现这种困惑，主要是队列和线程的概念没有分清。</p>
<p>线程是执行任务的，队列是保存任务的，队列遵循严格的FIFO原则。GCD根据队列的类型按照不同的方式取出任务放到线程执行。出现死锁的原因是队列的阻塞而不是线程的阻塞。</p>
<p>下面我画了张图来分析死锁的情况：</p>
<p><img src="/2019/01/06/iOS多线程之：GCD/死锁分析.jpg" alt="死锁分析"></p>
<p>下面来看看串行同步不会引起死锁的分析：</p>
<p><img src="/2019/01/06/iOS多线程之：GCD/串行同步分析.png" alt="串行同步"></p>
<h6 id="栅栏效应："><a href="#栅栏效应：" class="headerlink" title="栅栏效应："></a>栅栏效应：</h6><p>dispatch_barrier针对的是并发队列，但是注意：这个队列不可以是全局队列！！！</p>
<p>barrier就是栅栏的意思，dispatch_barrier可以保证当前队列中只有一个任务在执行中，在前面的任务执行结束后它才执行，而且它后面的任务等它执行完成之后才会执行。</p>
<p>dispatch_barrier提供了两种方式来保证只有一个任务在执行中</p>
<ul>
<li>dispatch_barrier_async</li>
<li>dispatch_barrier_sync</li>
</ul>
<p>区别：dispatch_barrier_async不用等到任务执行完毕就能往下执行，dispatch_barrier_sync要等到添加的任务执行完毕才能继续往下执行。</p>
<p>下面来看我写的一个dispatch_barrier_async_demo和打印效果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (void)dispatch_barrier_async_demo &#123;</span><br><span class="line">    dispatch_queue_t queue = dispatch_queue_create(&quot;gcdtest.rongfzh.yc&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;dispatch_async1&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_barrier_async(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;dispatch_barrier_async_start&quot;);</span><br><span class="line">        [NSThread sleepForTimeInterval:4];</span><br><span class="line">        NSLog(@&quot;dispatch_barrier_async_end&quot;);</span><br><span class="line">        </span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;dispatch_async3&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">控制台打印：</span><br><span class="line">2019-01-13 12:22:28.851753+0800 GCD_Demo[1392:110129] after diapatch barrier</span><br><span class="line">2019-01-13 12:22:28.851754+0800 GCD_Demo[1392:110169] task1</span><br><span class="line">2019-01-13 12:22:28.851869+0800 GCD_Demo[1392:110169] task2 start</span><br><span class="line">2019-01-13 12:22:32.855079+0800 GCD_Demo[1392:110169] task2 end</span><br><span class="line">2019-01-13 12:22:32.855434+0800 GCD_Demo[1392:110169] task3</span><br></pre></td></tr></table></figure>
<p>然后我们dispatch_barrier_async换成dispatch_barrier_sync：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (void)dispatch_barrier_sync_demo &#123;</span><br><span class="line">    dispatch_queue_t queue = dispatch_queue_create(&quot;gcdtest.rongfzh.yc&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;dispatch_async1&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_barrier_async(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;dispatch_barrier_async_start&quot;);</span><br><span class="line">        [NSThread sleepForTimeInterval:4];</span><br><span class="line">        NSLog(@&quot;dispatch_barrier_async_end&quot;);</span><br><span class="line">        </span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;dispatch_async3&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">控制台打印：</span><br><span class="line">2019-01-13 12:23:32.132838+0800 GCD_Demo[1407:112641] task1</span><br><span class="line">2019-01-13 12:23:32.132959+0800 GCD_Demo[1407:112605] task2 start</span><br><span class="line">2019-01-13 12:23:36.134056+0800 GCD_Demo[1407:112605] task2 end</span><br><span class="line">2019-01-13 12:23:36.134298+0800 GCD_Demo[1407:112605] after diapatch barrier</span><br><span class="line">2019-01-13 12:23:36.134507+0800 GCD_Demo[1407:112641] task3</span><br></pre></td></tr></table></figure>
<p><strong>说明：我们在task2中用一个延时操作来模拟耗时的任务，两个demo的区别就是after diapatch barrier的打印时机。通过dispatch_barrier_async方式，after diapatch barrier不用等到task2任务执行完就可以打印；通过dispatch_barrier_async方式，after diapatch barrier要等到task2任务执行完才可以打印。</strong></p>
<p><strong>dispatch_barrier_async的妙用：实现一个多读单写的多线程锁。</strong></p>
<p>多读单写的锁特点：</p>
<ul>
<li>在进行写操作的同时，不能同时有其他写操作或者读操作</li>
<li>允许多个读操作同时进行</li>
</ul>
<p>具体的实现方式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;TestClass.h&quot;</span><br><span class="line"></span><br><span class="line">@interface TestClass ()&#123;</span><br><span class="line">    NSString *_testName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, copy) NSString *testName;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, strong) dispatch_queue_t rw_queue;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@implementation TestClass</span><br><span class="line"></span><br><span class="line">- (instancetype)init</span><br><span class="line">&#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        _rw_queue = dispatch_queue_create(NULL, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setTestName:(NSString *)testName &#123;</span><br><span class="line">    dispatch_barrier_async(_rw_queue, ^&#123;</span><br><span class="line">        _testName = [testName copy];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSString *)testName &#123;</span><br><span class="line">    __block NSString *temp;</span><br><span class="line">    dispatch_sync(_rw_queue, ^&#123;</span><br><span class="line">        temp = _testName;</span><br><span class="line">    &#125;);</span><br><span class="line">    return temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<h6 id="dispatch-once"><a href="#dispatch-once" class="headerlink" title="dispatch_once"></a>dispatch_once</h6><p>dispatch_once用来执行只需要执行一次的任务，常常用来设计单利模式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">用法：</span><br><span class="line">- (void)once</span><br><span class="line">&#123;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">    	//需要单次执行的任务</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="调度组dispatch-group-t"><a href="#调度组dispatch-group-t" class="headerlink" title="调度组dispatch_group_t"></a>调度组dispatch_group_t</h6><p>我们在多线程开发中，经常会遇到在多个任务执行结束后再进行一些总结性的任务操作。这是GCD调度组就可以派上用场了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 实例化一个调度组</span><br><span class="line">dispatch_group_t group = dispatch_group_create();</span><br><span class="line">// 队列</span><br><span class="line">dispatch_queue_t queue = dispatch_get_global_queue(0, 0);</span><br><span class="line">// 任务添加到队列queue</span><br><span class="line">dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">	[NSThread sleepForTimeInterval:4];</span><br><span class="line">    NSLog(@&quot;耗时操作1&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">	[NSThread sleepForTimeInterval:2];</span><br><span class="line">    NSLog(@&quot;耗时操作2&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">	[NSThread sleepForTimeInterval:3];</span><br><span class="line">    NSLog(@&quot;耗时操作3&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_group_notify(group, queue, ^&#123;</span><br><span class="line">	NSLog(@&quot;所有操作都执行完了&quot;); // 异步的</span><br><span class="line">&#125;);</span><br><span class="line">控制台打印：</span><br><span class="line">2019-01-13 14:17:27.840243+0800 GCD_Demo[2498:289933] 耗时操作2</span><br><span class="line">2019-01-13 14:17:28.840083+0800 GCD_Demo[2498:289932] 耗时操作3</span><br><span class="line">2019-01-13 14:17:29.840024+0800 GCD_Demo[2498:289929] 耗时操作1</span><br><span class="line">2019-01-13 14:17:29.840398+0800 GCD_Demo[2498:289929] 所有操作都执行完了</span><br></pre></td></tr></table></figure>
<h6 id="延时操作dispatch-after"><a href="#延时操作dispatch-after" class="headerlink" title="延时操作dispatch_after"></a>延时操作dispatch_after</h6><p>经过某个时间后执行某个任务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dispatch_after(dispatch_time_t when, dispatch_queue_t queue,</span><br><span class="line">		dispatch_block_t block);</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/04/iOS多线程之：NSThread/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DevHuangjb">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="黄锦标的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/04/iOS多线程之：NSThread/" itemprop="url">iOS多线程之：NSThread</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-01-04T23:37:53+08:00">
                2019-01-04
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>线程的概念：线程，有时被称为轻量进程(Lightweight Process，LWP），是程序中一个单一的顺序控制流程。线程是进程中的一个实体，是被系统独立调度和分派的基本单位，线程自己不拥有系统资源，只拥有一点儿在运行中必不可少的资源，但它可与同属一个进程的其它线程共享进程所拥有的全部资源。</strong></p>
<p><strong>在单个程序中同时运行多个线程完成不同的工作，称为多线程。</strong></p>
<p>在iOS开发中，实现多线程的机制常用的有三种：NSThread，GCD dispatch，NSOperation。当然还有底层的pthread。</p>
<p>今天，我们先来聊聊NSThread。</p>
<h6 id="初始化NSThread"><a href="#初始化NSThread" class="headerlink" title="初始化NSThread"></a>初始化NSThread</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)initWithTarget:(id)target selector:(SEL)selector object:(nullable id)argument;</span><br><span class="line">//iOS10新出的api</span><br><span class="line">- (instancetype)initWithBlock:(void (^)(void))block;API_AVAILABLE(macosx(10.12), ios(10.0), watchos(3.0), tvos(10.0));</span><br></pre></td></tr></table></figure>
<p>初始化之后的NSThread要调用start才能开启线程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)start</span><br></pre></td></tr></table></figure>
<p>除了对象初始化方法，苹果还提供了便利的类方法来开启线程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//iOS10新出api</span><br><span class="line">+ (void)detachNewThreadWithBlock:(void (^)(void))block API_AVAILABLE(macosx(10.12), ios(10.0), watchos(3.0), tvos(10.0));</span><br><span class="line">+ (void)detachNewThreadSelector:(SEL)selector toTarget:(id)target withObject:(nullable id)argument;</span><br></pre></td></tr></table></figure>
<p>用类方法调度的线程默认就开启，不用调用start方法来启动。</p>
<h6 id="让线程睡一会："><a href="#让线程睡一会：" class="headerlink" title="让线程睡一会："></a>让线程睡一会：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+ (void)sleepUntilDate:(NSDate *)date;</span><br><span class="line">+ (void)sleepForTimeInterval:(NSTimeInterval)ti;</span><br></pre></td></tr></table></figure>
<h6 id="退出线程"><a href="#退出线程" class="headerlink" title="退出线程"></a>退出线程</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (void)exit;</span><br></pre></td></tr></table></figure>
<p>退出线程后，后面的程序流就不会执行了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void)threadRun:(NSString *)par &#123;</span><br><span class="line">    NSLog(@&quot;start&quot;);</span><br><span class="line">    [NSThread exit];</span><br><span class="line">    NSLog(@&quot;end&quot;);</span><br><span class="line">&#125;</span><br><span class="line">//控制台只输出start，之后线程就退出了</span><br><span class="line">2019-01-05 10:33:01.938485+0800 AnalyzeNSThread[2781:136475] start</span><br></pre></td></tr></table></figure>
<h6 id="取消线程"><a href="#取消线程" class="headerlink" title="取消线程"></a>取消线程</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)cancel;</span><br></pre></td></tr></table></figure>
<p>注意：调用cancel后，并不是直接取消退出线程，而是把线程的isCancelled 标志位置位YES。要退出线程还需要我们自己的线程执行中判断isCancelled然后调用exit来退出线程。</p>
<h6 id="设置线程的优先级"><a href="#设置线程的优先级" class="headerlink" title="设置线程的优先级"></a>设置线程的优先级</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+ (double)threadPriority;</span><br><span class="line">+ (BOOL)setThreadPriority:(double)p;</span><br></pre></td></tr></table></figure>
<p>一般开发中很少会设置线程的优先级，因为有可能会影响到内核调度线程，造成线程执行的卡顿。</p>
<h6 id="线程的属性"><a href="#线程的属性" class="headerlink" title="线程的属性"></a>线程的属性</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">//字典，可以添加其他信息</span><br><span class="line">@property (readonly, retain) NSMutableDictionary *threadDictionary;</span><br><span class="line">//线程的优先级</span><br><span class="line">@property double threadPriority</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">枚举的方式设置线程的优先级</span><br><span class="line">NSQualityOfServiceUserInteractive：最高优先级，主要用于提供交互UI的操作，比如处理点击事件，绘制图像到屏幕上</span><br><span class="line">NSQualityOfServiceUserInitiated：次高优先级，主要用于执行需要立即返回的任务</span><br><span class="line">NSQualityOfServiceDefault：默认优先级</span><br><span class="line">NSQualityOfServiceUtility：普通优先级，主要用于不需要立即返回的任务</span><br><span class="line">NSQualityOfServiceBackground：后台优先级，用于完全不紧急的任务，优先级最低</span><br><span class="line">*/</span><br><span class="line">@property NSQualityOfService qualityOfService</span><br><span class="line"></span><br><span class="line">//线程调用栈函数的返回地址</span><br><span class="line">@property (class, readonly, copy) NSArray&lt;NSNumber *&gt; *callStackReturnAddresses</span><br><span class="line">//线程调用栈函数的名称</span><br><span class="line">@property (class, readonly, copy) NSArray&lt;NSString *&gt; *callStackSymbols</span><br><span class="line">//线程名称</span><br><span class="line">@property (nullable, copy) NSString *name</span><br><span class="line">//线程栈大小</span><br><span class="line">@property NSUInteger stackSize</span><br><span class="line"></span><br><span class="line">@property (readonly) BOOL isMainThread</span><br><span class="line">@property (class, readonly) BOOL isMainThread</span><br><span class="line">@property (class, readonly, strong) NSThread *mainThread</span><br><span class="line"></span><br><span class="line">//线程是否执行中</span><br><span class="line">@property (readonly, getter=isExecuting) BOOL executing</span><br><span class="line">//线程是否结束</span><br><span class="line">@property (readonly, getter=isFinished) BOOL finished</span><br><span class="line">//线程是否取消</span><br><span class="line">@property (readonly, getter=isCancelled) BOOL cancelled</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/04/SDWebImage解析之SDWebImageDownloader/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DevHuangjb">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="黄锦标的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/04/SDWebImage解析之SDWebImageDownloader/" itemprop="url">SDWebImage解析之SDWebImageDownloader</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-01-04T19:02:05+08:00">
                2019-01-04
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>SDWebImageDownloaderOperation是针对图片的某个具体的下载任务。SDWebImageDownloader角色则是类似于一个下载器，可以发起执行一个或多个下载任务，并对这些任务进行管理：任务的执行顺序，停止任务，取消任务，控制任务的并发量等。</p>
<p><strong>首先来看一下SDWebImageDownloader.h头文件</strong></p>
<p>定义了一个下载的配置选项SDWebImageDownloaderOptions</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_OPTIONS(NSUInteger, SDWebImageDownloaderOptions) &#123;</span><br><span class="line">//下载优先级低</span><br><span class="line">    SDWebImageDownloaderLowPriority = 1,</span><br><span class="line">    SDWebImageDownloaderLowPriority = 2,</span><br><span class="line">    //渐进式的解码下载图片</span><br><span class="line">    SDWebImageDownloaderProgressiveDownload = 1 &lt;&lt; 1,</span><br><span class="line">    //配置了这个选项就会使用系统默认的缓存机制，否则使用SDImageCache缓存</span><br><span class="line">    SDWebImageDownloaderUseNSURLCache = 1 &lt;&lt; 2,</span><br><span class="line">    //结合SDWebImageDownloaderUseNSURLCache选项，忽略缓存的图片</span><br><span class="line">    SDWebImageDownloaderIgnoreCachedResponse = 1 &lt;&lt; 3,</span><br><span class="line">    //当app退到后台，申请后台继续下载</span><br><span class="line">    SDWebImageDownloaderContinueInBackground = 1 &lt;&lt; 4,</span><br><span class="line">    //设置NSMutableURLRequest.HTTPShouldHandleCookies = YES;</span><br><span class="line">    SDWebImageDownloaderHandleCookies = 1 &lt;&lt; 5,</span><br><span class="line">    //允许非法证书请求</span><br><span class="line">    SDWebImageDownloaderAllowInvalidSSLCertificates = 1 &lt;&lt; 6,</span><br><span class="line">    //下载优先级高</span><br><span class="line">    SDWebImageDownloaderHighPriority = 1 &lt;&lt; 7,</span><br><span class="line">    //如果下载的图片太大(大于60M)则对图片进行缩小</span><br><span class="line">    SDWebImageDownloaderScaleDownLargeImages = 1 &lt;&lt; 8,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>下面是任务执行的顺序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSInteger, SDWebImageDownloaderExecutionOrder) &#123;</span><br><span class="line">//先入先出</span><br><span class="line">    SDWebImageDownloaderFIFOExecutionOrder,</span><br><span class="line">    //先入后出</span><br><span class="line">    SDWebImageDownloaderLIFOExecutionOrder</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里有个类SDWebImageDownloadToken 用于关联某个特定的SDWebImageDownloaderOperation，可以让外界方便的取消下载中的任务。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//这个类遵守SDWebImageOperation协议，实现了cancel方法</span><br><span class="line">@interface SDWebImageDownloadToken : NSObject &lt;SDWebImageOperation&gt;</span><br><span class="line">//图片url</span><br><span class="line">@property (nonatomic, strong, nullable) NSURL *url;</span><br><span class="line">//SDWebImageDownloaderOperation： - (nullable id)addHandlersForProgress:completed:后返回的字典结构，里面包含这个operation的progressBlock和completedBlock</span><br><span class="line">@property (nonatomic, strong, nullable) id downloadOperationCancelToken;</span><br><span class="line">//关联的SDWebImageDownloaderOperation</span><br><span class="line">@property (nonatomic, weak, nullable) NSOperation&lt;SDWebImageDownloaderOperationInterface&gt; *downloadOperation;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation SDWebImageDownloadToken</span><br><span class="line">- (void)cancel &#123;</span><br><span class="line">    if (self.downloadOperation) &#123;</span><br><span class="line">        SDWebImageDownloadToken *cancelToken = self.downloadOperationCancelToken;</span><br><span class="line">        if (cancelToken) &#123;</span><br><span class="line">        //调用SDWebImageDownloaderOperation的 cancel:方法来移除回调函数，当所有回调函数都移除了，这个下载任务就会被取消掉</span><br><span class="line">            [self.downloadOperation cancel:cancelToken];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>下面来看看SDWebImageDownloader向外部暴露的属性和方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">@interface SDWebImageDownloader : NSObject</span><br><span class="line">//是否要对下载的图片预绘制解码</span><br><span class="line">@property (assign, nonatomic) BOOL shouldDecompressImages;</span><br><span class="line">//最大并发下载数</span><br><span class="line">@property (assign, nonatomic) NSInteger maxConcurrentDownloads;</span><br><span class="line">//当前下载任务数</span><br><span class="line">@property (readonly, nonatomic) NSUInteger currentDownloadCount;</span><br><span class="line">//超市时间,默认15s</span><br><span class="line">@property (assign, nonatomic) NSTimeInterval downloadTimeout;</span><br><span class="line">//内部用于配置NSUrlSession的NSURLSessionConfiguration</span><br><span class="line">@property (readonly, nonatomic, nonnull) NSURLSessionConfiguration *sessionConfiguration;</span><br><span class="line">//任务的执行顺序</span><br><span class="line">@property (assign, nonatomic) SDWebImageDownloaderExecutionOrder executionOrder;</span><br><span class="line">//单例获取</span><br><span class="line">+ (nonnull instancetype)sharedDownloader;</span><br><span class="line">//https证书</span><br><span class="line">@property (strong, nonatomic, nullable) NSURLCredential *urlCredential;</span><br><span class="line">@property (strong, nonatomic, nullable) NSString *username;</span><br><span class="line">@property (strong, nonatomic, nullable) NSString *password;</span><br><span class="line">//用于过滤http请求头参数</span><br><span class="line">@property (nonatomic, copy, nullable) SDWebImageDownloaderHeadersFilterBlock headersFilter;</span><br><span class="line">//</span><br><span class="line">- (nonnull instancetype)initWithSessionConfiguration:(nullable NSURLSessionConfiguration *)sessionConfiguration NS_DESIGNATED_INITIALIZER;</span><br><span class="line">//设置http请求头参数</span><br><span class="line">- (void)setValue:(nullable NSString *)value forHTTPHeaderField:(nullable NSString *)field;</span><br><span class="line">//获取指定http请求头信息</span><br><span class="line">- (nullable NSString *)valueForHTTPHeaderField:(nullable NSString *)field;</span><br><span class="line">//指定自定义的下载类</span><br><span class="line">- (void)setOperationClass:(nullable Class)operationClass;</span><br><span class="line">//下载图片，设置下载选项，指定回调block</span><br><span class="line">- (nullable SDWebImageDownloadToken *)downloadImageWithURL:(nullable NSURL *)url</span><br><span class="line">                                                   options:(SDWebImageDownloaderOptions)options</span><br><span class="line">                                                  progress:(nullable SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                                                 completed:(nullable SDWebImageDownloaderCompletedBlock)completedBlock;</span><br><span class="line">//取消</span><br><span class="line">- (void)cancel:(nullable SDWebImageDownloadToken *)token;</span><br><span class="line">//暂停</span><br><span class="line">- (void)setSuspended:(BOOL)suspended;</span><br><span class="line">//取消所有下载任务</span><br><span class="line">- (void)cancelAllDownloads;</span><br><span class="line">//重新指定NSURLSessionConfiguration配置NSUrlSession</span><br><span class="line">- (void)createNewSessionWithConfiguration:(nonnull NSURLSessionConfiguration *)sessionConfiguration;</span><br><span class="line">//使NSUrlSession失效，cancelPendingOperations：是否取消下载中的任务</span><br><span class="line">- (void)invalidateSessionAndCancel:(BOOL)cancelPendingOperations;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>接下来看看SDWebImageDownloader 的实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@interface SDWebImageDownloader () &lt;NSURLSessionTaskDelegate, NSURLSessionDataDelegate&gt;</span><br><span class="line">@property (strong, nonatomic, nonnull) NSOperationQueue *downloadQueue;</span><br><span class="line">//最后添加的任务：当指定为LIFO，如果有新下载任务，则之前最后添加的任务会依赖于新任务执行完达到LIFO效果</span><br><span class="line">@property (weak, nonatomic, nullable) NSOperation *lastAddedOperation;</span><br><span class="line">//自定义的下载类</span><br><span class="line">@property (assign, nonatomic, nullable) Class operationClass;</span><br><span class="line">//管理的下载任务集合</span><br><span class="line">@property (strong, nonatomic, nonnull) NSMutableDictionary&lt;NSURL *, SDWebImageDownloaderOperation *&gt; *URLOperations;</span><br><span class="line">//request请求头</span><br><span class="line">@property (strong, nonatomic, nullable) SDHTTPHeadersMutableDictionary *HTTPHeaders;</span><br><span class="line">//保证任务集合在多线程数据安全所用的信号量</span><br><span class="line">@property (strong, nonatomic, nonnull) dispatch_semaphore_t operationsLock; </span><br><span class="line">//保证HTTPHeaders在多线程数据安全所用的信号量</span><br><span class="line">@property (strong, nonatomic, nonnull) dispatch_semaphore_t headersLock; </span><br><span class="line">@property (strong, nonatomic) NSURLSession *session;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>在initialize中为请求添加指示器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">+ (void)initialize &#123;</span><br><span class="line">    // 我们需要额外导入SDNetworkActivityIndicator.h</span><br><span class="line">    if (NSClassFromString(@&quot;SDNetworkActivityIndicator&quot;)) &#123;</span><br><span class="line"></span><br><span class="line">#pragma clang diagnostic push</span><br><span class="line">#pragma clang diagnostic ignored &quot;-Warc-performSelector-leaks&quot;</span><br><span class="line">		//通过runtime来实例化一个指示器</span><br><span class="line">        id activityIndicator = [NSClassFromString(@&quot;SDNetworkActivityIndicator&quot;) performSelector:NSSelectorFromString(@&quot;sharedActivityIndicator&quot;)];</span><br><span class="line">#pragma clang diagnostic pop</span><br><span class="line"></span><br><span class="line">        // 因为指示器是用sharedActivityIndicator获取的单例，添加监听前先移除</span><br><span class="line">        [[NSNotificationCenter defaultCenter] removeObserver:activityIndicator name:SDWebImageDownloadStartNotification object:nil];</span><br><span class="line">        [[NSNotificationCenter defaultCenter] removeObserver:activityIndicator name:SDWebImageDownloadStopNotification object:nil];</span><br><span class="line">        [[NSNotificationCenter defaultCenter] addObserver:activityIndicator</span><br><span class="line">                                                 selector:NSSelectorFromString(@&quot;startActivity&quot;)</span><br><span class="line">                                                     name:SDWebImageDownloadStartNotification object:nil];</span><br><span class="line">        [[NSNotificationCenter defaultCenter] addObserver:activityIndicator</span><br><span class="line">                                                 selector:NSSelectorFromString(@&quot;stopActivity&quot;)</span><br><span class="line">                                                     name:SDWebImageDownloadStopNotification object:nil];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面来看构造函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">- (nonnull instancetype)initWithSessionConfiguration:(nullable NSURLSessionConfiguration *)sessionConfiguration &#123;</span><br><span class="line">    if ((self = [super init])) &#123;</span><br><span class="line">        _operationClass = [SDWebImageDownloaderOperation class];</span><br><span class="line">        //默认预绘制解码下载图片</span><br><span class="line">        _shouldDecompressImages = YES;</span><br><span class="line">        //默认FIFO执行顺序</span><br><span class="line">        _executionOrder = SDWebImageDownloaderFIFOExecutionOrder;</span><br><span class="line">        _downloadQueue = [NSOperationQueue new];</span><br><span class="line">        //默认并发数为6</span><br><span class="line">        _downloadQueue.maxConcurrentOperationCount = 6;</span><br><span class="line">        _downloadQueue.name = @&quot;com.hackemist.SDWebImageDownloader&quot;;</span><br><span class="line">        _URLOperations = [NSMutableDictionary new];</span><br><span class="line">#ifdef SD_WEBP</span><br><span class="line">        _HTTPHeaders = [@&#123;@&quot;Accept&quot;: @&quot;image/webp,image/*;q=0.8&quot;&#125; mutableCopy];</span><br><span class="line">#else</span><br><span class="line">        _HTTPHeaders = [@&#123;@&quot;Accept&quot;: @&quot;image/*;q=0.8&quot;&#125; mutableCopy];</span><br><span class="line">#endif</span><br><span class="line">        _operationsLock = dispatch_semaphore_create(1);</span><br><span class="line">        _headersLock = dispatch_semaphore_create(1);</span><br><span class="line">        //默认超时时间15s</span><br><span class="line">        _downloadTimeout = 15.0;</span><br><span class="line">        [self createNewSessionWithConfiguration:sessionConfiguration];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面来看看如何发起和管理一个下载任务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (nullable SDWebImageDownloadToken *)downloadImageWithURL:(nullable NSURL *)url</span><br><span class="line">                                                   options:(SDWebImageDownloaderOptions)options</span><br><span class="line">                                                  progress:(nullable SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                                                 completed:(nullable SDWebImageDownloaderCompletedBlock)completedBlock</span><br></pre></td></tr></table></figure>
<p>内部调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (nullable SDWebImageDownloadToken *)addProgressCallback:(SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                                           completedBlock:(SDWebImageDownloaderCompletedBlock)completedBlock</span><br><span class="line">                                                   forURL:(nullable NSURL *)url</span><br><span class="line">                                           createCallback:(SDWebImageDownloaderOperation *(^)(void))createCallback</span><br></pre></td></tr></table></figure>
<p>来为一个SDWebImageDownloaderOperation 添加progressBlock和completedBlock。同时传递了一个createCallback来实例化一个SDWebImageDownloaderOperation。</p>
<p>我们来看看如何实例化一个SDWebImageDownloaderOperation:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">__strong __typeof (wself) sself = wself;</span><br><span class="line"> NSTimeInterval timeoutInterval = sself.downloadTimeout;</span><br><span class="line"> if (timeoutInterval == 0.0) &#123;</span><br><span class="line">     timeoutInterval = 15.0;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> // 是否使用系统默认的缓存策略</span><br><span class="line"> NSURLRequestCachePolicy cachePolicy = options &amp; SDWebImageDownloaderUseNSURLCache ? NSURLRequestUseProtocolCachePolicy : NSURLRequestReloadIgnoringLocalCacheData;</span><br><span class="line"> NSMutableURLRequest *request = [[NSMutableURLRequest alloc] initWithURL:url</span><br><span class="line">                                                             cachePolicy:cachePolicy</span><br><span class="line">                                                         timeoutInterval:timeoutInterval];</span><br><span class="line"> </span><br><span class="line"> request.HTTPShouldHandleCookies = (options &amp; SDWebImageDownloaderHandleCookies);</span><br><span class="line"> request.HTTPShouldUsePipelining = YES;</span><br><span class="line"> if (sself.headersFilter) &#123;</span><br><span class="line"> //如果指定过滤请求头，使用block过滤</span><br><span class="line">     request.allHTTPHeaderFields = sself.headersFilter(url, [sself allHTTPHeaderFields]);</span><br><span class="line"> &#125;</span><br><span class="line"> else &#123;</span><br><span class="line">     request.allHTTPHeaderFields = [sself allHTTPHeaderFields];</span><br><span class="line"> &#125;</span><br><span class="line"> SDWebImageDownloaderOperation *operation = [[sself.operationClass alloc] initWithRequest:request inSession:sself.session options:options];</span><br><span class="line"> operation.shouldDecompressImages = sself.shouldDecompressImages;</span><br><span class="line"> </span><br><span class="line"> if (sself.urlCredential) &#123;</span><br><span class="line">     operation.credential = sself.urlCredential;</span><br><span class="line"> &#125; else if (sself.username &amp;&amp; sself.password) &#123;</span><br><span class="line">     operation.credential = [NSURLCredential credentialWithUser:sself.username password:sself.password persistence:NSURLCredentialPersistenceForSession];</span><br><span class="line"> &#125;</span><br><span class="line"> //通过下载选项配置请求优先级</span><br><span class="line"> if (options &amp; SDWebImageDownloaderHighPriority) &#123;</span><br><span class="line">     operation.queuePriority = NSOperationQueuePriorityHigh;</span><br><span class="line"> &#125; else if (options &amp; SDWebImageDownloaderLowPriority) &#123;</span><br><span class="line">     operation.queuePriority = NSOperationQueuePriorityLow;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> if (sself.executionOrder == SDWebImageDownloaderLIFOExecutionOrder) &#123;</span><br><span class="line"> //指定LIFO</span><br><span class="line">     [sself.lastAddedOperation addDependency:operation];</span><br><span class="line">     sself.lastAddedOperation = operation;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> return operation;</span><br></pre></td></tr></table></figure>
<p>下面来看看如何关联回调block:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">- (nullable SDWebImageDownloadToken *)addProgressCallback:(SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                                           completedBlock:(SDWebImageDownloaderCompletedBlock)completedBlock</span><br><span class="line">                                                   forURL:(nullable NSURL *)url</span><br><span class="line">                                           createCallback:(SDWebImageDownloaderOperation *(^)(void))createCallback &#123;</span><br><span class="line">    if (url == nil) &#123;</span><br><span class="line">        if (completedBlock != nil) &#123;</span><br><span class="line">            completedBlock(nil, nil, nil, NO);</span><br><span class="line">        &#125;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    LOCK(self.operationsLock);</span><br><span class="line">    //首先确认下这个operation是否已经在任务集合中，保证当前针对一个url只有一个下载任务，防止同一时刻反复下载一张图片</span><br><span class="line">    SDWebImageDownloaderOperation *operation = [self.URLOperations objectForKey:url];</span><br><span class="line">    if (!operation || operation.isFinished) &#123;</span><br><span class="line">        operation = createCallback();</span><br><span class="line">        __weak typeof(self) wself = self;</span><br><span class="line">        operation.completionBlock = ^&#123;</span><br><span class="line">            __strong typeof(wself) sself = wself;</span><br><span class="line">            if (!sself) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            LOCK(sself.operationsLock);</span><br><span class="line">            [sself.URLOperations removeObjectForKey:url];</span><br><span class="line">            UNLOCK(sself.operationsLock);</span><br><span class="line">        &#125;;</span><br><span class="line">        [self.URLOperations setObject:operation forKey:url];</span><br><span class="line">        //添加到下载队列，开始下载</span><br><span class="line">        [self.downloadQueue addOperation:operation];</span><br><span class="line">    &#125;</span><br><span class="line">    UNLOCK(self.operationsLock);</span><br><span class="line">	</span><br><span class="line">//为operation增加回调block</span><br><span class="line">    id downloadOperationCancelToken = [operation addHandlersForProgress:progressBlock completed:completedBlock];</span><br><span class="line">    //配置SDWebImageDownloadToken，包装了回调函数，operation,url。返回给外包调用者来管理下载任务</span><br><span class="line">    SDWebImageDownloadToken *token = [SDWebImageDownloadToken new];</span><br><span class="line">    token.downloadOperation = operation;</span><br><span class="line">    token.url = url;</span><br><span class="line">    token.downloadOperationCancelToken = downloadOperationCancelToken;</span><br><span class="line"></span><br><span class="line">    return token;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于NSURLSession代理方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark NSURLSessionDataDelegate</span><br><span class="line"></span><br><span class="line">- (void)URLSession:(NSURLSession *)session</span><br><span class="line">          dataTask:(NSURLSessionDataTask *)dataTask</span><br><span class="line">didReceiveResponse:(NSURLResponse *)response</span><br><span class="line"> completionHandler:(void (^)(NSURLSessionResponseDisposition disposition))completionHandler &#123;</span><br><span class="line">    SDWebImageDownloaderOperation *dataOperation = [self operationWithTask:dataTask];</span><br><span class="line">    if ([dataOperation respondsToSelector:@selector(URLSession:dataTask:didReceiveResponse:completionHandler:)]) &#123;</span><br><span class="line">        [dataOperation URLSession:session dataTask:dataTask didReceiveResponse:response completionHandler:completionHandler];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (completionHandler) &#123;</span><br><span class="line">            completionHandler(NSURLSessionResponseAllow);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>都是通过这种形式来把代理操作转发到SDWebImageDownloaderOperation的代理方法里面去执行。</p>
<p>operationWithTask通过NSURLSessionTask的taskIdentifier匹配来找出相对应的SDWebImageDownloaderOperation。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (SDWebImageDownloaderOperation *)operationWithTask:(NSURLSessionTask *)task &#123;</span><br><span class="line">    SDWebImageDownloaderOperation *returnOperation = nil;</span><br><span class="line">    for (SDWebImageDownloaderOperation *operation in self.downloadQueue.operations) &#123;</span><br><span class="line">        if (operation.dataTask.taskIdentifier == task.taskIdentifier) &#123;</span><br><span class="line">            returnOperation = operation;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return returnOperation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/31/SDWebImage解析之SDWebImageDownloaderOperation/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DevHuangjb">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="黄锦标的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/31/SDWebImage解析之SDWebImageDownloaderOperation/" itemprop="url">SDWebImage解析之SDWebImageDownloaderOperation</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-31T12:57:31+08:00">
                2018-12-31
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>根据我阅读源码的习惯，我会先阅读比较核心的，并且没有或者较少引入其他文件的类。所以，就让我们先从SDWebImageDownloaderOperation说起吧。</p>
<p>在iOS9.0之后，苹果推出了NSUrlSession，并推荐开发者用NSUrlSession替代NSUrlConnection。如果我们自己用NSUrlSession来请求图片，主要有：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NSURLSession *session = [NSURLSession sessionWithConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration] delegate:self delegateQueue:nil];</span><br><span class="line">NSURLRequest *request = [NSURLRequest requestWithURL:[NSURL URLWithString:@&quot;http://pic27.nipic.com/20130329/890845_115317964000_2.jpg&quot;]];</span><br><span class="line">NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request];</span><br><span class="line">[dataTask resume];</span><br></pre></td></tr></table></figure>
<p>delegateQueue：为执行代理方法的队列，不指定session默认会创建一个<strong>serial operation queue</strong> </p>
<p>在回调的代理方法中处理数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark NSURLSessionDataDelegate</span><br><span class="line">- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveData:(NSData *)data &#123;</span><br><span class="line">    [self.imageData appendData:data];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didCompleteWithError:(NSError *)error &#123;</span><br><span class="line">    UIImage *image = [UIImage imageWithData:self.imageData];</span><br><span class="line">    dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        self.imageView.image = image;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>SDWebImageDownloaderOperation是NSOperaion的子类，就是用来封装上面的下载操作</strong></p>
<p>先来看看SDWebImageDownloaderOperation.h</p>
<p>文件一开始向外部暴露了四个通知：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//下载开始</span><br><span class="line">FOUNDATION_EXPORT NSString * _Nonnull const SDWebImageDownloadStartNotification;</span><br><span class="line">//接受到服务器响应</span><br><span class="line">FOUNDATION_EXPORT NSString * _Nonnull const SDWebImageDownloadReceiveResponseNotification;</span><br><span class="line">//下载停止</span><br><span class="line">FOUNDATION_EXPORT NSString * _Nonnull const SDWebImageDownloadStopNotification;</span><br><span class="line">//下载结束</span><br><span class="line">FOUNDATION_EXPORT NSString * _Nonnull const SDWebImageDownloadFinishNotification;</span><br></pre></td></tr></table></figure>
<p>在UIView+WebCache分类中，就是对SDWebImageDownloadStartNotification和SDWebImageDownloadFinishNotification通知的监听来添加和移除UIActivityIndicatorView 。</p>
<p>在SDWebImageDownloaderOperation.h头文件中，定义了SDWebImageDownloaderOperationInterface 协议。我们可以继承NSOperation同时遵守SDWebImageDownloaderOperationInterface协议来自定义下载操作类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@protocol SDWebImageDownloaderOperationInterface&lt;NSObject&gt;</span><br><span class="line">- (nonnull instancetype)initWithRequest:(nullable NSURLRequest *)request</span><br><span class="line">                              inSession:(nullable NSURLSession *)session</span><br><span class="line">                                options:(SDWebImageDownloaderOptions)options;</span><br><span class="line">//为下载操作添加下载中和下载完成的回调</span><br><span class="line">- (nullable id)addHandlersForProgress:(nullable SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                            completed:(nullable SDWebImageDownloaderCompletedBlock)completedBlock;</span><br><span class="line">//是否需要对下载的图片进行预解码</span><br><span class="line">- (BOOL)shouldDecompressImages;</span><br><span class="line">- (void)setShouldDecompressImages:(BOOL)value;</span><br><span class="line">//https证书</span><br><span class="line">- (nullable NSURLCredential *)credential;</span><br><span class="line">- (void)setCredential:(nullable NSURLCredential *)value;</span><br><span class="line">//取消下载操作</span><br><span class="line">- (BOOL)cancel:(nullable id)token;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>在SDWebImageDownloaderOperation类的私有拓展中包含以下属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//包含下载操作回调block的数组</span><br><span class="line">@property (strong, nonatomic, nonnull) NSMutableArray&lt;SDCallbacksDictionary *&gt; *callbackBlocks;</span><br><span class="line">//下载运行中</span><br><span class="line">@property (assign, nonatomic, getter = isExecuting) BOOL executing;</span><br><span class="line">//下载结束</span><br><span class="line">@property (assign, nonatomic, getter = isFinished) BOOL finished;</span><br><span class="line">//拼接的数据</span><br><span class="line">@property (strong, nonatomic, nullable) NSMutableData *imageData;</span><br><span class="line">//使用NSUrlCache缓存的数据</span><br><span class="line">@property (copy, nonatomic, nullable) NSData *cachedData;</span><br><span class="line">//外部注入的NSURLSession，因为在SDWebImageDownloader中已经对这个session强引用，所有使用weak</span><br><span class="line">@property (weak, nonatomic, nullable) NSURLSession *unownedSession;</span><br><span class="line">//如果外部没有注入session，内部会自己实例化一个session，并负责这个session的生命周期</span><br><span class="line">@property (strong, nonatomic, nullable) NSURLSession *ownedSession;</span><br><span class="line">//通过UrlRequest生成的dataTask请求任务</span><br><span class="line">@property (strong, nonatomic, readwrite, nullable) NSURLSessionTask *dataTask;</span><br><span class="line">//为保证在多线程环境下操作callbackBlocks的数据安全提供的锁</span><br><span class="line">@property (strong, nonatomic, nonnull) dispatch_semaphore_t callbacksLock; </span><br><span class="line">//对图片进行解码的队列</span><br><span class="line">@property (strong, nonatomic, nonnull) dispatch_queue_t coderQueue;</span><br><span class="line">#if SD_UIKIT</span><br><span class="line">//app退到后台后向UIApplication注册的后台任务标识，可以获得一些额外的下载时间</span><br><span class="line">@property (assign, nonatomic) UIBackgroundTaskIdentifier backgroundTaskId;</span><br><span class="line">#endif</span><br><span class="line">//对图片进行渐进式解码的解码器</span><br><span class="line">@property (strong, nonatomic, nullable) id&lt;SDWebImageProgressiveCoder&gt; progressiveCoder;</span><br></pre></td></tr></table></figure>
<p>下面来看一下SDWebImageDownloaderOperation的构造函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- (nonnull instancetype)init &#123;</span><br><span class="line">    return [self initWithRequest:nil inSession:nil options:0];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (nonnull instancetype)initWithRequest:(nullable NSURLRequest *)request</span><br><span class="line">                              inSession:(nullable NSURLSession *)session</span><br><span class="line">                                options:(SDWebImageDownloaderOptions)options &#123;</span><br><span class="line">    if ((self = [super init])) &#123;</span><br><span class="line">        _request = [request copy];</span><br><span class="line">        //默认需要对图片进行预解码</span><br><span class="line">        _shouldDecompressImages = YES;</span><br><span class="line">        _options = options;</span><br><span class="line">        _callbackBlocks = [NSMutableArray new];</span><br><span class="line">        _executing = NO;</span><br><span class="line">        _finished = NO;</span><br><span class="line">        _expectedSize = 0;</span><br><span class="line">        _unownedSession = session;</span><br><span class="line">        _callbacksLock = dispatch_semaphore_create(1);</span><br><span class="line">        _coderQueue = dispatch_queue_create(&quot;com.hackemist.SDWebImageDownloaderOperationCoderQueue&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为SDWebImageDownloaderOperation添加回调block:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (nullable id)addHandlersForProgress:(nullable SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                            completed:(nullable SDWebImageDownloaderCompletedBlock)completedBlock &#123;</span><br><span class="line">    SDCallbacksDictionary *callbacks = [NSMutableDictionary new];</span><br><span class="line">    if (progressBlock) callbacks[kProgressCallbackKey] = [progressBlock copy];</span><br><span class="line">    if (completedBlock) callbacks[kCompletedCallbackKey] = [completedBlock copy];</span><br><span class="line">    LOCK(self.callbacksLock);</span><br><span class="line">    [self.callbackBlocks addObject:callbacks];</span><br><span class="line">    UNLOCK(self.callbacksLock);</span><br><span class="line">    return callbacks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>progressBlock和completeBlock最终会以@{@”progress “:progressBlock,@”completed”:completedBlock}的形式添加callbackBlocks数组。</p>
<p>下面是通过字符串来获取所有的progressBlock或者所有的completedBlock：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (nullable NSArray&lt;id&gt; *)callbacksForKey:(NSString *)key &#123;</span><br><span class="line">    LOCK(self.callbacksLock);</span><br><span class="line">    //NSArray对KVC的拓展，所有元素都会执行valueForKey: 方法，并把结果添加到数组返回。如果valueForKey:返回nil，则会把NSNull添加进数组。</span><br><span class="line">    NSMutableArray&lt;id&gt; *callbacks = [[self.callbackBlocks valueForKey:key] mutableCopy];</span><br><span class="line">    UNLOCK(self.callbacksLock);</span><br><span class="line">    // We need to remove [NSNull null] because there might not always be a progress block for each callback</span><br><span class="line">    [callbacks removeObjectIdenticalTo:[NSNull null]];</span><br><span class="line">    return [callbacks copy]; // strip mutability here</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面的代码是移除某一组回调的block:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)cancel:(nullable id)token &#123;</span><br><span class="line">    BOOL shouldCancel = NO;</span><br><span class="line">    LOCK(self.callbacksLock);</span><br><span class="line">    [self.callbackBlocks removeObjectIdenticalTo:token];</span><br><span class="line">    if (self.callbackBlocks.count == 0) &#123;</span><br><span class="line">    	//当所有的回调都被移除，就没有下载的必要了。</span><br><span class="line">        shouldCancel = YES;</span><br><span class="line">    &#125;</span><br><span class="line">    UNLOCK(self.callbacksLock);</span><br><span class="line">    if (shouldCancel) &#123;</span><br><span class="line">        [self cancel];</span><br><span class="line">    &#125;</span><br><span class="line">    return shouldCancel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面来看看[self cancel]做了什么：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">- (void)cancel &#123;</span><br><span class="line">    @synchronized (self) &#123;</span><br><span class="line">        [self cancelInternal];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)cancelInternal &#123;</span><br><span class="line">    if (self.isFinished) return;</span><br><span class="line">    //把operation置为取消状态</span><br><span class="line">    [super cancel];</span><br><span class="line"></span><br><span class="line">    if (self.dataTask) &#123;</span><br><span class="line">    	//取消下载任务</span><br><span class="line">        [self.dataTask cancel];</span><br><span class="line">        __weak typeof(self) weakSelf = self;</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            [[NSNotificationCenter defaultCenter] postNotificationName:SDWebImageDownloadStopNotification object:weakSelf];</span><br><span class="line">        &#125;);</span><br><span class="line">        if (self.isExecuting) self.executing = NO;</span><br><span class="line">        if (!self.isFinished) self.finished = YES;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [self reset];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)reset &#123;</span><br><span class="line">    LOCK(self.callbacksLock);</span><br><span class="line">    //移除所有回调</span><br><span class="line">    [self.callbackBlocks removeAllObjects];</span><br><span class="line">    UNLOCK(self.callbacksLock);</span><br><span class="line">    //释放请求任务</span><br><span class="line">    self.dataTask = nil;</span><br><span class="line">    if (self.ownedSession) &#123;</span><br><span class="line">    	//释放内部生产的session</span><br><span class="line">        [self.ownedSession invalidateAndCancel];</span><br><span class="line">        self.ownedSession = nil;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要就是对取消之后资源的管理和状态的维护。</p>
<p>下面来看看最主要的start方法，当SDWebImageDownloaderOperation添加到并发队列，就会调用start方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">- (void)start &#123;</span><br><span class="line">    @synchronized (self) &#123;</span><br><span class="line">    	//如果operatin被取消，置位finished标志，并释放资源</span><br><span class="line">        if (self.isCancelled) &#123;</span><br><span class="line">            self.finished = YES;</span><br><span class="line">            [self reset];</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">#flag:注册后台任务</span><br><span class="line">#if SD_UIKIT</span><br><span class="line">        Class UIApplicationClass = NSClassFromString(@&quot;UIApplication&quot;);</span><br><span class="line">        BOOL hasApplication = UIApplicationClass &amp;&amp; [UIApplicationClass respondsToSelector:@selector(sharedApplication)];</span><br><span class="line">        if (hasApplication &amp;&amp; [self shouldContinueWhenAppEntersBackground]) &#123;</span><br><span class="line">            __weak __typeof__ (self) wself = self;</span><br><span class="line">            UIApplication * app = [UIApplicationClass performSelector:@selector(sharedApplication)];</span><br><span class="line">            //当app即将退到后台，想UIApplication注册一个后台执行的任务，以获取额外的操作时间</span><br><span class="line">            self.backgroundTaskId = [app beginBackgroundTaskWithExpirationHandler:^&#123;</span><br><span class="line">                __strong __typeof (wself) sself = wself;</span><br><span class="line">                if (sself) &#123;</span><br><span class="line">                	//当额外的时间后仍没有完成下载任务，则取消掉任务</span><br><span class="line">                    [sself cancel];</span><br><span class="line">                    [app endBackgroundTask:sself.backgroundTaskId];</span><br><span class="line">                    sself.backgroundTaskId = UIBackgroundTaskInvalid;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;];</span><br><span class="line">        &#125;</span><br><span class="line">#endif</span><br><span class="line">        NSURLSession *session = self.unownedSession;</span><br><span class="line">        if (!session) &#123;</span><br><span class="line">        	//如果外部没有注入session，内部负责生成并管理一个session</span><br><span class="line">            NSURLSessionConfiguration *sessionConfig = [NSURLSessionConfiguration defaultSessionConfiguration];</span><br><span class="line">            //SDWebImage默认的超时时间为15秒</span><br><span class="line">            sessionConfig.timeoutIntervalForRequest = 15;</span><br><span class="line">            session = [NSURLSession sessionWithConfiguration:sessionConfig</span><br><span class="line">                                                    delegate:self</span><br><span class="line">                                               delegateQueue:nil];</span><br><span class="line">            self.ownedSession = session;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if (self.options &amp; SDWebImageDownloaderIgnoreCachedResponse) &#123;</span><br><span class="line">            NSURLCache *URLCache = session.configuration.URLCache;</span><br><span class="line">            if (!URLCache) &#123;</span><br><span class="line">                URLCache = [NSURLCache sharedURLCache];</span><br><span class="line">            &#125;</span><br><span class="line">            NSCachedURLResponse *cachedResponse;</span><br><span class="line">            @synchronized (URLCache) &#123;</span><br><span class="line">            	//根据请求拿到缓存的响应</span><br><span class="line">                cachedResponse = [URLCache cachedResponseForRequest:self.request];</span><br><span class="line">            &#125;</span><br><span class="line">            if (cachedResponse) &#123;</span><br><span class="line">            	//拿到NSUrlCache缓存的响应对应的数据</span><br><span class="line">                self.cachedData = cachedResponse.data;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      	//实例化下载任务</span><br><span class="line">        self.dataTask = [session dataTaskWithRequest:self.request];</span><br><span class="line">    	//设为运行中</span><br><span class="line">        self.executing = YES;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (self.dataTask) &#123;</span><br><span class="line">#pragma clang diagnostic push</span><br><span class="line">#pragma clang diagnostic ignored &quot;-Wunguarded-availability&quot;</span><br><span class="line">        if ([self.dataTask respondsToSelector:@selector(setPriority:)]) &#123;</span><br><span class="line">        	//根据下载配置参数设置下载任务的优先级</span><br><span class="line">            if (self.options &amp; SDWebImageDownloaderHighPriority) &#123;</span><br><span class="line">                self.dataTask.priority = NSURLSessionTaskPriorityHigh;</span><br><span class="line">            &#125; else if (self.options &amp; SDWebImageDownloaderLowPriority) &#123;</span><br><span class="line">                self.dataTask.priority = NSURLSessionTaskPriorityLow;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">#pragma clang diagnostic pop</span><br><span class="line">		//开始下载任务</span><br><span class="line">        [self.dataTask resume];</span><br><span class="line">        for (SDWebImageDownloaderProgressBlock progressBlock in [self callbacksForKey:kProgressCallbackKey]) &#123;</span><br><span class="line">            progressBlock(0, NSURLResponseUnknownLength, self.request.URL);</span><br><span class="line">        &#125;</span><br><span class="line">        __weak typeof(self) weakSelf = self;</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        	//下载开始通知</span><br><span class="line">            [[NSNotificationCenter defaultCenter] postNotificationName:SDWebImageDownloadStartNotification object:weakSelf];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">    	//如果下载任务实例化失败，则以错误的状态调用completedBlock回调</span><br><span class="line">        [self callCompletionBlocksWithError:[NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorUnknown userInfo:@&#123;NSLocalizedDescriptionKey : @&quot;Task can&apos;t be initialized&quot;&#125;]];</span><br><span class="line">        [self done];</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">#从&quot;flag:注册后台任务&quot;到这行代码区间的代码，就是app退到后台向UIApplication注册的backgroundTask</span><br><span class="line">#if SD_UIKIT</span><br><span class="line">    Class UIApplicationClass = NSClassFromString(@&quot;UIApplication&quot;);</span><br><span class="line">    if(!UIApplicationClass || ![UIApplicationClass respondsToSelector:@selector(sharedApplication)]) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (self.backgroundTaskId != UIBackgroundTaskInvalid) &#123;</span><br><span class="line">        UIApplication * app = [UIApplication performSelector:@selector(sharedApplication)];</span><br><span class="line">        [app endBackgroundTask:self.backgroundTaskId];</span><br><span class="line">        self.backgroundTaskId = UIBackgroundTaskInvalid;</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行start后下载开始，接下来就是监听NSURLSessionDelegate 的代理方法来处理数据了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">//接受到服务器响应数据</span><br><span class="line">- (void)URLSession:(NSURLSession *)session</span><br><span class="line">          dataTask:(NSURLSessionDataTask *)dataTask</span><br><span class="line">didReceiveResponse:(NSURLResponse *)response</span><br><span class="line"> completionHandler:(void (^)(NSURLSessionResponseDisposition disposition))completionHandler &#123;</span><br><span class="line">    NSURLSessionResponseDisposition disposition = NSURLSessionResponseAllow;</span><br><span class="line">    //请求的图片大小</span><br><span class="line">    NSInteger expected = (NSInteger)response.expectedContentLength;</span><br><span class="line">    expected = expected &gt; 0 ? expected : 0;</span><br><span class="line">    self.expectedSize = expected;</span><br><span class="line">    self.response = response;</span><br><span class="line">    NSInteger statusCode = [response respondsToSelector:@selector(statusCode)] ? ((NSHTTPURLResponse *)response).statusCode : 200;</span><br><span class="line">    BOOL valid = statusCode &lt; 400;</span><br><span class="line">    //&apos;304 Not Modified&apos;代表资源未改变，本地又没有NSUrlCache缓存的数据，当成非法请求看待</span><br><span class="line">    if (statusCode == 304 &amp;&amp; !self.cachedData) &#123;</span><br><span class="line">        valid = NO;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (valid) &#123;</span><br><span class="line">    	//如果响应有效，则回调处理所有progressBlock</span><br><span class="line">        for (SDWebImageDownloaderProgressBlock progressBlock in [self callbacksForKey:kProgressCallbackKey]) &#123;</span><br><span class="line">            progressBlock(0, expected, self.request.URL);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //取消后续下载</span><br><span class="line">        disposition = NSURLSessionResponseCancel;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    __weak typeof(self) weakSelf = self;</span><br><span class="line">    dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        [[NSNotificationCenter defaultCenter] postNotificationName:SDWebImageDownloadReceiveResponseNotification object:weakSelf];</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    if (completionHandler) &#123;</span><br><span class="line">        completionHandler(disposition);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">//接受到下载的数据包</span><br><span class="line">- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveData:(NSData *)data &#123;</span><br><span class="line">    if (!self.imageData) &#123;</span><br><span class="line">        self.imageData = [[NSMutableData alloc] initWithCapacity:self.expectedSize];</span><br><span class="line">    &#125;</span><br><span class="line">    //数据拼接</span><br><span class="line">    [self.imageData appendData:data];</span><br><span class="line">	//如果配置渐进式的下载，则对当前数据进行渐进式解码</span><br><span class="line">    if ((self.options &amp; SDWebImageDownloaderProgressiveDownload) &amp;&amp; self.expectedSize &gt; 0) &#123;</span><br><span class="line">        __block NSData *imageData = [self.imageData copy];</span><br><span class="line">        const NSInteger totalSize = imageData.length;</span><br><span class="line">        BOOL finished = (totalSize &gt;= self.expectedSize);</span><br><span class="line">        if (!self.progressiveCoder) &#123;</span><br><span class="line">        	//实例化解码器</span><br><span class="line">            for (id&lt;SDWebImageCoder&gt;coder in [SDWebImageCodersManager sharedInstance].coders) &#123;</span><br><span class="line">                if ([coder conformsToProtocol:@protocol(SDWebImageProgressiveCoder)] &amp;&amp;</span><br><span class="line">                    [((id&lt;SDWebImageProgressiveCoder&gt;)coder) canIncrementallyDecodeFromData:imageData]) &#123;</span><br><span class="line">                    self.progressiveCoder = [[[coder class] alloc] init];</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //解码是一个耗时的操作，在解码队列上异步解码图片</span><br><span class="line">        dispatch_async(self.coderQueue, ^&#123;</span><br><span class="line">            UIImage *image = [self.progressiveCoder incrementallyDecodedImageWithData:imageData finished:finished];</span><br><span class="line">            if (image) &#123;</span><br><span class="line">                NSString *key = [[SDWebImageManager sharedManager] cacheKeyForURL:self.request.URL];</span><br><span class="line">                image = [self scaledImageForKey:key image:image];</span><br><span class="line">                //如果需要，对图片进行预绘制解码</span><br><span class="line">                if (self.shouldDecompressImages) &#123;</span><br><span class="line">                    image = [[SDWebImageCodersManager sharedInstance] decompressedImageWithImage:image data:&amp;imageData options:@&#123;SDWebImageCoderScaleDownLargeImagesKey: @(NO)&#125;];</span><br><span class="line">                &#125;</span><br><span class="line">                //每次解码调用completedBlock进行UIView的渲染</span><br><span class="line">                [self callCompletionBlocksWithImage:image imageData:nil error:nil finished:NO];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">	//回调处理所有progressBlock</span><br><span class="line">    for (SDWebImageDownloaderProgressBlock progressBlock in [self callbacksForKey:kProgressCallbackKey]) &#123;</span><br><span class="line">        progressBlock(self.imageData.length, self.expectedSize, self.request.URL);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">//下载完成的回调</span><br><span class="line">- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didCompleteWithError:(NSError *)error &#123;</span><br><span class="line">    @synchronized(self) &#123;</span><br><span class="line">        self.dataTask = nil;</span><br><span class="line">        __weak typeof(self) weakSelf = self;</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        	//发送下载停止通知</span><br><span class="line">            [[NSNotificationCenter defaultCenter] postNotificationName:SDWebImageDownloadStopNotification object:weakSelf];</span><br><span class="line">            if (!error) &#123;</span><br><span class="line">            	//如果下载没有错误，发送下载完成通知</span><br><span class="line">                [[NSNotificationCenter defaultCenter] postNotificationName:SDWebImageDownloadFinishNotification object:weakSelf];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //下载出错，以错误的状态调用completedBlock，同时把operation设置finished状态</span><br><span class="line">    if (error) &#123;</span><br><span class="line">        [self callCompletionBlocksWithError:error];</span><br><span class="line">        [self done];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if ([self callbacksForKey:kCompletedCallbackKey].count &gt; 0) &#123;</span><br><span class="line">            __block NSData *imageData = [self.imageData copy];</span><br><span class="line">            if (imageData) &#123;</span><br><span class="line">            	//这边为什么下载数据等于缓存数据要以nil调用completedBlock不是很懂，希望了解的人告知一二</span><br><span class="line">                if (self.options &amp; SDWebImageDownloaderIgnoreCachedResponse &amp;&amp; [self.cachedData isEqualToData:imageData]) &#123;</span><br><span class="line">                    [self callCompletionBlocksWithImage:nil imageData:nil error:nil finished:YES];</span><br><span class="line">                    [self done];</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    // 在解码队列上异步解码图片</span><br><span class="line">                    dispatch_async(self.coderQueue, ^&#123;</span><br><span class="line">                        UIImage *image = [[SDWebImageCodersManager sharedInstance] decodedImageWithData:imageData];</span><br><span class="line">                        NSString *key = [[SDWebImageManager sharedManager] cacheKeyForURL:self.request.URL];</span><br><span class="line">                        image = [self scaledImageForKey:key image:image];</span><br><span class="line">                        </span><br><span class="line">                        BOOL shouldDecode = YES;</span><br><span class="line">                        // GIFs and WebPs不支持解码</span><br><span class="line">                        if (image.images) &#123;</span><br><span class="line">                            shouldDecode = NO;</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">#ifdef SD_WEBP</span><br><span class="line">                            SDImageFormat imageFormat = [NSData sd_imageFormatForImageData:imageData];</span><br><span class="line">                            if (imageFormat == SDImageFormatWebP) &#123;</span><br><span class="line">                                shouldDecode = NO;</span><br><span class="line">                            &#125;</span><br><span class="line">#endif</span><br><span class="line">                        &#125;</span><br><span class="line">                        </span><br><span class="line">                        if (shouldDecode) &#123;</span><br><span class="line">                        	//如果需要，预绘制解码图片</span><br><span class="line">                            if (self.shouldDecompressImages) &#123;</span><br><span class="line">                                BOOL shouldScaleDown = self.options &amp; SDWebImageDownloaderScaleDownLargeImages;</span><br><span class="line">                                image = [[SDWebImageCodersManager sharedInstance] decompressedImageWithImage:image data:&amp;imageData options:@&#123;SDWebImageCoderScaleDownLargeImagesKey: @(shouldScaleDown)&#125;];</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        CGSize imageSize = image.size;</span><br><span class="line">                        if (imageSize.width == 0 || imageSize.height == 0) &#123;</span><br><span class="line">                        	//当下载的图片大小为0，以错误的状态回调completedBlock</span><br><span class="line">                            [self callCompletionBlocksWithError:[NSError errorWithDomain:SDWebImageErrorDomain code:0 userInfo:@&#123;NSLocalizedDescriptionKey : @&quot;Downloaded image has 0 pixels&quot;&#125;]];</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                        	//回调函数completedBlock处理下载的图片</span><br><span class="line">                            [self callCompletionBlocksWithImage:image imageData:imageData error:nil finished:YES];</span><br><span class="line">                        &#125;</span><br><span class="line">                        [self done];</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">            	//当下载的图片为空，以错误的状态回调completedBlock</span><br><span class="line">                [self callCompletionBlocksWithError:[NSError errorWithDomain:SDWebImageErrorDomain code:0 userInfo:@&#123;NSLocalizedDescriptionKey : @&quot;Image data is nil&quot;&#125;]];</span><br><span class="line">                [self done];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            [self done];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>细心的你可能会发现，这些代理方法只是对ownedSession而言，那么对于unownedSession 如何监听呢？unownedSession代理方法由SDWebImageDownloader监听，然后一一转发到SDWebImageDownloaderOperation的代理方法中进行处理。这些我们在SDWebImageDownloader的解析中将会看到。</p>
<p>以上关于解码的部分只是一笔略过，以后会专门写一篇。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/28/SDWebImage源码解析/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DevHuangjb">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="黄锦标的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/28/SDWebImage源码解析/" itemprop="url">SDWebImage源码解析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-28T17:16:28+08:00">
                2018-12-28
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>要想成为优秀，要先模仿优秀，书法如此，代码也如此。<br>我们总可以在阅读优秀源码有所收获，你会发现，原来，代码可以这么写！</p>
</blockquote>
<p>接触iOS开发的同学都接触过这个框架。SDWebImage作者精简的接口设计极大的简化了我们开发中有关图片的需求场景。正因为这样，不少开发者对SDWebImage仅仅停留在使用上面，而没有去剖析框架。</p>
<p>我们先来看下SDWebImage架构图：<br><img src="/2018/12/28/SDWebImage源码解析/SDWebImageArchitecture.png" alt="架构图"><br>从框架图可以看出主要包括：</p>
<ul>
<li>核心类: SDWebImageManager</li>
<li>图片下载：SDWebImageDownloader</li>
<li>图片缓存：SdImageCache</li>
<li>UIKit拓展分类：UIView，UIImageView，UIButton等分类</li>
<li>图片编解码类：SDWebImageCodersManager</li>
<li>其他辅助类</li>
</ul>
<p>从功能上来看，各个类的职责都很清晰。</p>
<p>下面来看一下SDWebImage工作的时序图：<br><img src="/2018/12/28/SDWebImage源码解析/SDWebImage_sequence.png" alt="时序图"><br>主业务线：UIImageView通过调用UIView:sd_internalSetImageWithURL；然后调用SDWebImageManager:loadImageWithUrl；SDWebImageManager去查询SdImageCache是否有图片，如果有直接返回图片，如果没有调用SDWebImageDownloader下载图片；SDWebImageDownloader下载完图片会调用SDImageCache对图片进行缓存。</p>
<p>具体的细节后面将会在各个模块的专题中解析。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/28/写在前面/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DevHuangjb">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="黄锦标的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/28/写在前面/" itemprop="url">写在前面</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-28T14:57:59+08:00">
                2018-12-28
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/diary/" itemprop="url" rel="index">
                    <span itemprop="name">diary</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>2018年12月28日了。</strong></p>
<p>转眼间又快到跨年的时候了。。</p>
<p><strong>为什么写博客？</strong></p>
<p>其实这个念头已经藏了一两年了。无奈迫于精力（其实主要是因为懒）一直搁置到现在。</p>
<p>2015年接触iOS开发以来，为了效率开发笔记一直都是依靠有道云笔记。这让我有点闭门造车的感觉，所以我打算把笔记整理一下发到博客上来。</p>
<p>以前拜读YYKit作者<a href="https://blog.ibireme.com/" target="_blank" rel="noopener">郭耀源的博客</a>只是看一些技术类的文章。前段时间无意翻到作者2010年发布的日记，其中作者在调通iPhone真机调试后说了一句话“看看我以后还有兴趣的话就继续学一下了~谁知道呢。。。”  谁知道呢？后来YYKit能收到这么大的反响。YYKit的成功让我觉得这句话很有意思。</p>
<p>人生充满未知数，仅以本博客记录点滴。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.gif" alt="DevHuangjb">
            
              <p class="site-author-name" itemprop="name">DevHuangjb</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/DevHuangjb" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.jianshu.com/u/ba146c0c3280" target="_blank" title="简书">
                      
                        <i class="fa fa-fw fa-globe"></i>简书</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">DevHuangjb</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
