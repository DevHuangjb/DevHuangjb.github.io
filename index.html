<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="黄锦标的博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="黄锦标的博客">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="黄锦标的博客">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>黄锦标的博客</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">黄锦标的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">记录学习点滴，好记性 < 烂笔头！</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-首页">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-ios">
          <a href="/categories/iOS/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-apple"></i> <br>
            
            iOS
          </a>
        </li>
      
        
        <li class="menu-item menu-item-日常">
          <a href="/categories/diary/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-calendar"></i> <br>
            
            日常
          </a>
        </li>
      
        
        <li class="menu-item menu-item-标签">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-归档">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/03/Mach-O文件简介和fishhook原理解析/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DevHuangjb">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="黄锦标的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/03/Mach-O文件简介和fishhook原理解析/" itemprop="url">Mach-O文件简介和fishhook原理解析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-03T16:58:00+08:00">
                2019-04-03
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>利用runtime这个黑魔法可以hook Objective-c的方法。</p>
<p>如果有一个hook C语言函数的需求(比如NSLog()函数)，那该如何完成？</p>
<p><strong>Facebook</strong>开源的C函数库<strong>fishhook</strong>是一种解决方案。</p>
<blockquote>
<p><strong>fishhook</strong> is a very simple library that enables dynamically rebinding symbols in Mach-O binaries running on iOS in the simulator and on device. </p>
</blockquote>
<p>以上摘自 <a href="https://github.com/facebook/fishhook" target="_blank" rel="noopener">fishhook</a> README.md：fishhook是一个简单的动态重新绑定Mach-O二进制文件的符号。</p>
<p>多简单？整个库不到200行代码。却收获了3000多个star。不愧为神作！</p>
<p>fishhook的工作原理是解析Mach-O二进制文件，找到要重新绑定的符号所在的位置，替换掉符号要跳转的执行代码地址从而达到hook的目的。</p>
<p>所以，在解析fishhook原理之前，让我们先来了解一下Mach-O文件。</p>
<h3 id="Mach-O文件"><a href="#Mach-O文件" class="headerlink" title="Mach-O文件"></a>Mach-O文件</h3><p>什么是Mach-O文件：Mach-O格式全称为Mach Object文件格式的缩写，是Mac/iOS上用于存储程序，库的标准文件。我们在开发中常见的 ‘.o’、’.a’、’.dSYM’、App包里的二进制执行文件、framework等都输入Mach-O文件的范畴。</p>
<p>利用命令：$ file mach-o文件   可以得到Mach-O文件的类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//查看app包里的二进制执行文件类型：Mach-O文件，64位，可执行文件，arm64架构</span><br><span class="line">Huangjb:Desktop mac$ file TestFishHook </span><br><span class="line">TestFishHook: Mach-O 64-bit executable arm64</span><br></pre></td></tr></table></figure>
<p>查看Mach-O文件最方便的方法就是用MachOView.app查看。</p>
<p><img src="/2019/04/03/Mach-O文件简介和fishhook原理解析/mach-o_file.jpg" alt="MachOView查看"></p>
<p>可以看出Mach-O文件主要有三部分：</p>
<ul>
<li>mach header</li>
<li>load commands</li>
<li>raw datas</li>
</ul>
<h4 id="mach-header信息"><a href="#mach-header信息" class="headerlink" title="mach header信息"></a>mach header信息</h4><p><img src="/2019/04/03/Mach-O文件简介和fishhook原理解析/mach-header.jpg" alt="mach header"></p>
<p>在mach/loader.h总定义了mach header相关的结构体：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">//32位 mach_header</span><br><span class="line">struct mach_header &#123;</span><br><span class="line">	uint32_t	magic;		/* mach magic number identifier */</span><br><span class="line">	cpu_type_t	cputype;	/* cpu specifier */</span><br><span class="line">	cpu_subtype_t	cpusubtype;	/* machine specifier */</span><br><span class="line">	uint32_t	filetype;	/* type of file */</span><br><span class="line">	uint32_t	ncmds;		/* number of load commands */</span><br><span class="line">	uint32_t	sizeofcmds;	/* the size of all the load commands */</span><br><span class="line">	uint32_t	flags;		/* flags */</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">***************** 参数解析 *****************</span><br><span class="line">magic：魔数</span><br><span class="line">有四种值：0xfeedface(MH_MAGIC：32位大端模式)，0xcefaedfe(MH_CIGAM：32位小端模式)</span><br><span class="line">				0xfeedfacf(MH_MAGIC_64：64位大端模式)，0xcffaedfe(MH_CIGAM_64：64小端模式)</span><br><span class="line">				</span><br><span class="line">cputype：cpu类型</span><br><span class="line"></span><br><span class="line">cpusubtype：cpu子类型</span><br><span class="line"></span><br><span class="line">filetype：mach-o文件类型，mach/loader.h中定义了文件类型对应的值</span><br><span class="line">#define	MH_OBJECT	0x1		/* relocatable object file */</span><br><span class="line">#define	MH_EXECUTE	0x2		/* demand paged executable file */</span><br><span class="line">#define	MH_FVMLIB	0x3		/* fixed VM shared library file */</span><br><span class="line">#define	MH_CORE		0x4		/* core file */</span><br><span class="line">#define	MH_PRELOAD	0x5		/* preloaded executable file */</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">ncmds：load commands的数量</span><br><span class="line"></span><br><span class="line">sizeofcmds：load commands区域的大小</span><br></pre></td></tr></table></figure>
<h4 id="LoadCommands信息"><a href="#LoadCommands信息" class="headerlink" title="LoadCommands信息"></a>LoadCommands信息</h4><p>LoadCommands位于mach header后面，为dyld加载二进制文件到内存中提供信息。LoadCommands会告诉dyld从mach-o文件某个偏移处，加载多大的数据，加载到虚拟内存哪个地址等信息。可以说，load commands 是整个mach-o文件的蓝图。</p>
<p>load commands有多种类型，不同类型的数据不一样。但是所有的类型都包含cmd和cmdsize两个信息，对应的结构体</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct load_command &#123;</span><br><span class="line">	uint32_t cmd;		/* 加载命令类型 */</span><br><span class="line">	uint32_t cmdsize;	/* 加载命令大小 */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>load commands类型：</p>
<ul>
<li>_PAGEZERO：空指针陷阱？</li>
<li>_TEXT: 程序代码段</li>
<li>_DATA: 程序数据段可读写区</li>
<li>_RODATA:程序只读数据段</li>
<li>_LINKEDIT：链接编辑器段</li>
<li>LC_SYMTAB：符号表信息</li>
<li>LC_DYSYMTAB:动态符号表信息</li>
<li>LC_LOAD_DYLINKER：dyld的路径，一般是/usr/lib/dyld，内核根据这个位置加载dyld</li>
<li>LC_UUID:生成的唯一标识符</li>
<li>LC_SOURCE_VERSION：版本信息</li>
<li>LC_MAIN：程序执行的主函数入口</li>
<li>LC_ENCRYPTION_INFO：加密信息，crpyt id为1表示加壳</li>
<li>LC_LOAD_DYLIB：加载的动态库信息</li>
<li>LC_CODE_SIGNATURE：文件的签名信息</li>
</ul>
<p>cmd类型为LC_SEGMENT的加载命令对应的结构体如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct segment_command &#123; /* for 32-bit architectures */</span><br><span class="line">	uint32_t	cmd;		/* cmd类型 */</span><br><span class="line">	uint32_t	cmdsize;	/* 大小 */</span><br><span class="line">	char		segname[16];	/* segment name */</span><br><span class="line">	uint32_t	vmaddr;		/* 虚拟内存地址 */</span><br><span class="line">	uint32_t	vmsize;		/* 占的虚拟内存大小 */</span><br><span class="line">	uint32_t	fileoff;	/* 在mach-o文件的偏移 */</span><br><span class="line">	uint32_t	filesize;	/* 在mach-o所占大小 */</span><br><span class="line">	vm_prot_t	maxprot;	/* 段的页面所需要的最高内存保护 */</span><br><span class="line">	vm_prot_t	initprot;	/* 段页面初始化的内存保护 */</span><br><span class="line">	uint32_t	nsects;		/* 包含的section数量 */</span><br><span class="line">	uint32_t	flags;		/* flags */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>_TEXT、 _DATA、 _RODATA又包含若干个section。</p>
<p>有几个section跟我们今天讨论的主题相关：</p>
<ul>
<li><p>_TEXT : __stubs 用于动态库链接的桩    </p>
</li>
<li><p>_TEXT : __stub_helper 用于动态库链接的桩的辅助</p>
</li>
<li><p>_DATA： __la_symbol_ptr 延迟加载符号指针表</p>
</li>
<li><p>_DATA： __nl_symbol_ptr 非延迟加载符号指针表</p>
</li>
</ul>
<p>section对应的结构体：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct section &#123; /* for 32-bit architectures */</span><br><span class="line">	char		sectname[16];	/* section名字 */</span><br><span class="line">	char		segname[16];	/* section所在的segment名称 */</span><br><span class="line">	uint32_t	addr;		/* 虚拟内存地址 */</span><br><span class="line">	uint32_t	size;		/* section大小 */</span><br><span class="line">	uint32_t	offset;		/* 在mach-o文件的偏移 */</span><br><span class="line">	uint32_t	align;		/* 字节大小对齐 */</span><br><span class="line">	uint32_t	reloff;		/* 重定位入口的文件偏移 */</span><br><span class="line">	uint32_t	nreloc;		/* 需要重定位的入口数量 */</span><br><span class="line">	uint32_t	flags;		/* 包含section的type和attributes*/</span><br><span class="line">	uint32_t	reserved1;	/* reserved (for offset or index) */</span><br><span class="line">	uint32_t	reserved2;	/* reserved (for count or sizeof) */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="fishhook原理"><a href="#fishhook原理" class="headerlink" title="fishhook原理"></a>fishhook原理</h3><p>App调用外部库函数的时候，因为库函数是以动态库的形式存在于共享内存中，加上ASLR技术的影响，每次启动后内存地址都会有一个随机的偏移地址，所以在编译的时候并不能确定库函数的执行地址。</p>
<p>所以，为了能够准确的访问到外部库函数的，苹果采用了一种叫做PIC(位置代码独立)技术。</p>
<ul>
<li><p>对于非懒加载符号表_nl_symbol_ptr，dyld会立刻马上去链接动态库</p>
</li>
<li><p>对于延迟加载符号表 _la_symbol_ptr，编译的时候会在Mach-O的数据段的_nl_symbol_ptr区保留一个指针(初始化全为0)，用来指向外部函数。后期，dyld会动态的设置这个指针指向外部库函数的内存地址</p>
</li>
<li>对于延迟加载的外部库函数，当我们在App中运行中第一次去调用库函数时，借助于_stubs -&gt; _la_symbol_ptr -&gt; _stub_helper -&gt; _nl_symbol_ptr的一系列跳转可以得到外部库函数的内存地址。随后dyld会把 _la_symbol_ptr直接指向外部库函数的内存地址(这也是 _la_symbol_ptr为什么叫做延迟加载区)</li>
</ul>
<p>_nl_symbol_ptr和 _la_symbol_ptr位于Mach-O的DATA段。用户可以去修改这两个区的数据，把这两个区的指针指向我们自定义的函数指针，达到hook的目的。fishhook就是基于这个原理。</p>
<p><strong>注意：对于程序内部的C函数，函数地址在编译的时候就已经确定在了_TEXT代码段中，所以不能够修改，这也是fishhook不能hook内部C函数的原因！</strong></p>
<h5 id="fishhook官方原理图"><a href="#fishhook官方原理图" class="headerlink" title="fishhook官方原理图"></a>fishhook官方原理图</h5><p><img src="/2019/04/03/Mach-O文件简介和fishhook原理解析/fishhook.png" alt=""></p>
<h5 id="用法：-摘自github"><a href="#用法：-摘自github" class="headerlink" title="用法：(摘自github)"></a>用法：(<a href="https://github.com/facebook/fishhook" target="_blank" rel="noopener">摘自github</a>)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;dlfcn.h&gt;</span><br><span class="line"></span><br><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line"></span><br><span class="line">#import &quot;AppDelegate.h&quot;</span><br><span class="line">#import &quot;fishhook.h&quot;</span><br><span class="line"> </span><br><span class="line">//指针用来接收原系统close函数指针</span><br><span class="line">static int (*orig_close)(int);</span><br><span class="line">//指针用来接收原系统open函数指针</span><br><span class="line">static int (*orig_open)(const char *, int, ...);</span><br><span class="line"> </span><br><span class="line">//要替换系统close的函数</span><br><span class="line">int my_close(int fd) &#123;</span><br><span class="line">  printf(&quot;Calling real close(%d)\n&quot;, fd);</span><br><span class="line">  return orig_close(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//要替换系统open的函数</span><br><span class="line">int my_open(const char *path, int oflag, ...) &#123;</span><br><span class="line">  va_list ap = &#123;0&#125;;</span><br><span class="line">  mode_t mode = 0;</span><br><span class="line"> </span><br><span class="line">  if ((oflag &amp; O_CREAT) != 0) &#123;</span><br><span class="line">    // mode only applies to O_CREAT</span><br><span class="line">    va_start(ap, oflag);</span><br><span class="line">    mode = va_arg(ap, int);</span><br><span class="line">    va_end(ap);</span><br><span class="line">    printf(&quot;Calling real open(&apos;%s&apos;, %d, %d)\n&quot;, path, oflag, mode);</span><br><span class="line">    return orig_open(path, oflag, mode);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    printf(&quot;Calling real open(&apos;%s&apos;, %d)\n&quot;, path, oflag);</span><br><span class="line">    return orig_open(path, oflag, mode);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main(int argc, char * argv[])</span><br><span class="line">&#123;</span><br><span class="line">  @autoreleasepool &#123;</span><br><span class="line">    rebind_symbols((struct rebinding[2])&#123;&#123;&quot;close&quot;, my_close, (void *)&amp;orig_close&#125;, &#123;&quot;open&quot;, my_open, (void *)&amp;orig_open&#125;&#125;, 2);</span><br><span class="line"> </span><br><span class="line">    // Open our own binary and print out first 4 bytes (which is the same</span><br><span class="line">    // for all Mach-O binaries on a given architecture)</span><br><span class="line">    int fd = open(argv[0], O_RDONLY);</span><br><span class="line">    uint32_t magic_number = 0;</span><br><span class="line">    read(fd, &amp;magic_number, 4);</span><br><span class="line">    printf(&quot;Mach-O Magic Number: %x \n&quot;, magic_number);</span><br><span class="line">    close(fd);</span><br><span class="line"> </span><br><span class="line">    return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="源码解析："><a href="#源码解析：" class="headerlink" title="源码解析："></a>源码解析：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">//定义一个数据结构</span><br><span class="line">struct rebinding &#123;</span><br><span class="line">  const char *name;		//要重新绑定的的函数名称</span><br><span class="line">  void *replacement;	//替换的函数指针</span><br><span class="line">  void **replaced;		//定义一个指针指向原函数的地址</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//定义一个链表节点数据结构</span><br><span class="line">struct rebindings_entry &#123;</span><br><span class="line">  struct rebinding *rebindings;		//rebinding数组指针</span><br><span class="line">  size_t rebindings_nel;					//要重新绑定的函数个数</span><br><span class="line">  struct rebindings_entry *next;	//链表节点next指针</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//全局的重新绑定的链表头指针</span><br><span class="line">static struct rebindings_entry *_rebindings_head;</span><br><span class="line"></span><br><span class="line">static int prepend_rebindings(struct rebindings_entry **rebindings_head,</span><br><span class="line">                              struct rebinding rebindings[],</span><br><span class="line">                              size_t nel) &#123;</span><br><span class="line">  //新建一个链表节点                            </span><br><span class="line">  struct rebindings_entry *new_entry = (struct rebindings_entry *) malloc(sizeof(struct rebindings_entry));</span><br><span class="line">  if (!new_entry) &#123;</span><br><span class="line">    return -1;</span><br><span class="line">  &#125;</span><br><span class="line">  new_entry-&gt;rebindings = (struct rebinding *) malloc(sizeof(struct rebinding) * nel);</span><br><span class="line">  if (!new_entry-&gt;rebindings) &#123;</span><br><span class="line">    free(new_entry);</span><br><span class="line">    return -1;</span><br><span class="line">  &#125;</span><br><span class="line">  //把包含重新绑定信息的若干个rebinding设置到新建节点的rebindings成员</span><br><span class="line">  memcpy(new_entry-&gt;rebindings, rebindings, sizeof(struct rebinding) * nel);</span><br><span class="line">  //设置这个节点要重新绑定的函数的个数</span><br><span class="line">  new_entry-&gt;rebindings_nel = nel;</span><br><span class="line">  //新节点作为链表头，拼接本来的链表</span><br><span class="line">  new_entry-&gt;next = *rebindings_head;</span><br><span class="line">  *rebindings_head = new_entry;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int rebind_symbols(struct rebinding rebindings[], size_t rebindings_nel) &#123;</span><br><span class="line">  //在链表头增加新的节点</span><br><span class="line">  int retval = prepend_rebindings(&amp;_rebindings_head, rebindings, rebindings_nel);</span><br><span class="line">  if (retval &lt; 0) &#123;</span><br><span class="line">    return retval;</span><br><span class="line">  &#125;</span><br><span class="line">  if (!_rebindings_head-&gt;next) &#123; </span><br><span class="line">    //首次调用，注册系统回调</span><br><span class="line">    _dyld_register_func_for_add_image(_rebind_symbols_for_image);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    uint32_t c = _dyld_image_count();</span><br><span class="line">    for (uint32_t i = 0; i &lt; c; i++) &#123;</span><br><span class="line">      _rebind_symbols_for_image(_dyld_get_image_header(i), _dyld_get_image_vmaddr_slide(i));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//回调函数</span><br><span class="line">//const struct mach_header *header：mach_header的地址</span><br><span class="line">//intptr_t slide:slide ASLR随机偏移量</span><br><span class="line">static void _rebind_symbols_for_image(const struct mach_header *header,</span><br><span class="line">                                      intptr_t slide) &#123;                            </span><br><span class="line">    rebind_symbols_for_image(_rebindings_head, header, slide);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">static void rebind_symbols_for_image(struct rebindings_entry *rebindings,</span><br><span class="line">                                     const struct mach_header *header,</span><br><span class="line">                                     intptr_t slide) &#123;</span><br><span class="line">  Dl_info info;</span><br><span class="line">  if (dladdr(header, &amp;info) == 0) &#123;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  segment_command_t *cur_seg_cmd;</span><br><span class="line">  segment_command_t *linkedit_segment = NULL;</span><br><span class="line">  struct symtab_command* symtab_cmd = NULL;</span><br><span class="line">  struct dysymtab_command* dysymtab_cmd = NULL;</span><br><span class="line"></span><br><span class="line">  //得到load command的起始地址</span><br><span class="line">  uintptr_t cur = (uintptr_t)header + sizeof(mach_header_t);</span><br><span class="line">  </span><br><span class="line">  //遍历load commands区域，得到linkedit_segment，symtab_cmd，dysymtab_cmd的地址</span><br><span class="line">  for (uint i = 0; i &lt; header-&gt;ncmds; i++, cur += cur_seg_cmd-&gt;cmdsize) &#123;</span><br><span class="line">    cur_seg_cmd = (segment_command_t *)cur;</span><br><span class="line">    //LC_SEGMENT指令</span><br><span class="line">    if (cur_seg_cmd-&gt;cmd == LC_SEGMENT_ARCH_DEPENDENT) &#123;  </span><br><span class="line">      //__LINKEDIT段</span><br><span class="line">      if (strcmp(cur_seg_cmd-&gt;segname, SEG_LINKEDIT) == 0) &#123;</span><br><span class="line">      	//记录__LINKEDIT段地址</span><br><span class="line">        linkedit_segment = cur_seg_cmd;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else if (cur_seg_cmd-&gt;cmd == LC_SYMTAB) &#123; //符号表</span><br><span class="line">    	//记录symtab地址</span><br><span class="line">      symtab_cmd = (struct symtab_command*)cur_seg_cmd;</span><br><span class="line">    &#125; else if (cur_seg_cmd-&gt;cmd == LC_DYSYMTAB) &#123;//动态符号表</span><br><span class="line">    	//记录dysymtab地址</span><br><span class="line">      dysymtab_cmd = (struct dysymtab_command*)cur_seg_cmd;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (!symtab_cmd || !dysymtab_cmd || !linkedit_segment ||</span><br><span class="line">      !dysymtab_cmd-&gt;nindirectsyms) &#123;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //确定ASLR随机偏移后，mach-header的内存地址</span><br><span class="line">  uintptr_t linkedit_base = (uintptr_t)slide + linkedit_segment-&gt;vmaddr - linkedit_segment-&gt;fileoff;</span><br><span class="line">  </span><br><span class="line">  //计算Symbol Table的位置</span><br><span class="line">  nlist_t *symtab = (nlist_t *)(linkedit_base + symtab_cmd-&gt;symoff);</span><br><span class="line">  </span><br><span class="line">  //计算String Table的位置</span><br><span class="line">  char *strtab = (char *)(linkedit_base + symtab_cmd-&gt;stroff);</span><br><span class="line"></span><br><span class="line">  //计算Dynamic Symbol Table的位置 </span><br><span class="line">  uint32_t *indirect_symtab = (uint32_t *)(linkedit_base + dysymtab_cmd-&gt;indirectsymoff);</span><br><span class="line"></span><br><span class="line">  cur = (uintptr_t)header + sizeof(mach_header_t);</span><br><span class="line">  //再一次遍历load commands区域</span><br><span class="line">  for (uint i = 0; i &lt; header-&gt;ncmds; i++, cur += cur_seg_cmd-&gt;cmdsize) &#123;</span><br><span class="line">    cur_seg_cmd = (segment_command_t *)cur;</span><br><span class="line">    //LC_SEGMENT</span><br><span class="line">    if (cur_seg_cmd-&gt;cmd == LC_SEGMENT_ARCH_DEPENDENT) &#123;</span><br><span class="line">      //跳过不是DATA段的load command</span><br><span class="line">      if (strcmp(cur_seg_cmd-&gt;segname, SEG_DATA) != 0 &amp;&amp;</span><br><span class="line">          strcmp(cur_seg_cmd-&gt;segname, SEG_DATA_CONST) != 0) &#123;</span><br><span class="line">        continue;</span><br><span class="line">      &#125;</span><br><span class="line">      //遍历load command中__DATA中的section</span><br><span class="line">      for (uint j = 0; j &lt; cur_seg_cmd-&gt;nsects; j++) &#123;</span><br><span class="line">        section_t *sect =</span><br><span class="line">          (section_t *)(cur + sizeof(segment_command_t)) + j;</span><br><span class="line">          //__la_symbol_ptr区</span><br><span class="line">        if ((sect-&gt;flags &amp; SECTION_TYPE) == S_LAZY_SYMBOL_POINTERS) &#123;</span><br><span class="line">          perform_rebinding_with_section(rebindings, sect, slide, symtab, strtab, indirect_symtab);</span><br><span class="line">        &#125;</span><br><span class="line">        //__nl_symbol_ptr区</span><br><span class="line">        if ((sect-&gt;flags &amp; SECTION_TYPE) == S_NON_LAZY_SYMBOL_POINTERS) &#123;</span><br><span class="line">          perform_rebinding_with_section(rebindings, sect, slide, symtab, strtab, indirect_symtab);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">//fishhook通过函数名找到函数指针并替换</span><br><span class="line">static void perform_rebinding_with_section(struct rebindings_entry *rebindings,</span><br><span class="line">                                           section_t *section,</span><br><span class="line">                                           intptr_t slide,</span><br><span class="line">                                           nlist_t *symtab,</span><br><span class="line">                                           char *strtab,</span><br><span class="line">                                           uint32_t *indirect_symtab) &#123;</span><br><span class="line">  //获取__la_symbol_ptr区或__nl_symbol_ptr在indirect symtab表中的起始地址                                     </span><br><span class="line">  uint32_t *indirect_symbol_indices = indirect_symtab + section-&gt;reserved1;</span><br><span class="line">  </span><br><span class="line">  //计算__la_symbol_ptr区或__nl_symbol_ptr区内存地址</span><br><span class="line">  void **indirect_symbol_bindings = (void **)((uintptr_t)slide + section-&gt;addr);</span><br><span class="line">  </span><br><span class="line">  //计算（延时/非延时）加载区的大小，并遍历</span><br><span class="line">  for (uint i = 0; i &lt; section-&gt;size / sizeof(void *); i++) &#123;</span><br><span class="line">    uint32_t symtab_index = indirect_symbol_indices[i];</span><br><span class="line">    if (symtab_index == INDIRECT_SYMBOL_ABS || symtab_index == INDIRECT_SYMBOL_LOCAL ||</span><br><span class="line">        symtab_index == (INDIRECT_SYMBOL_LOCAL   | INDIRECT_SYMBOL_ABS)) &#123;</span><br><span class="line">      continue;</span><br><span class="line">    &#125;</span><br><span class="line">    //获取符号在String Table中的偏移</span><br><span class="line">    uint32_t strtab_offset = symtab[symtab_index].n_un.n_strx;</span><br><span class="line">    //获取符号名字</span><br><span class="line">    char *symbol_name = strtab + strtab_offset;</span><br><span class="line">    //_是符号的开始，&apos;\0&apos;是字符串结束符，所以一个合法的符号至少要包含&apos;_&apos;和除&apos;\0&apos;以外的其他字符</span><br><span class="line">    bool symbol_name_longer_than_1 = symbol_name[0] &amp;&amp; symbol_name[1];</span><br><span class="line">    struct rebindings_entry *cur = rebindings;</span><br><span class="line">    while (cur) &#123;</span><br><span class="line">     //遍历链表，将替换成新实现，保存老实现 </span><br><span class="line">      for (uint j = 0; j &lt; cur-&gt;rebindings_nel; j++) &#123;</span><br><span class="line">      	//匹配函数名，strcmp比较字符串函数，碰到&apos;\0&apos;字符函数结束，字符串相等返回0</span><br><span class="line">        if (strcmp(&amp;symbol_name[1], cur-&gt;rebindings[j].name) == 0) &#123;</span><br><span class="line">          if (cur-&gt;rebindings[j].replaced != NULL &amp;&amp;</span><br><span class="line">              indirect_symbol_bindings[i] != cur-&gt;rebindings[j].replacement) &#123;</span><br><span class="line">              //保存绑定前的函数指针</span><br><span class="line">            *(cur-&gt;rebindings[j].replaced) = indirect_symbol_bindings[i];</span><br><span class="line">          &#125;</span><br><span class="line">          //替换新实现函数指针</span><br><span class="line">          indirect_symbol_bindings[i] = cur-&gt;rebindings[j].replacement;</span><br><span class="line">          goto symbol_loop;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">  symbol_loop:;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/28/arm64汇编简单笔记/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DevHuangjb">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="黄锦标的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/28/arm64汇编简单笔记/" itemprop="url">arm64汇编简单笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-03-28T15:17:25+08:00">
                2019-03-28
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>学汇编最主要的是要搞懂：寄存器，指令和堆栈三个方面。</p>
<p>iPhone5S后，苹果都采用ARM64架构。</p>
<p>本文主要介绍ARM64汇编寄存器和常用指令集。</p>
<h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><p>ARM64架构中共有34个寄存器,包括31个通用寄存器、SP、PC、CPSR。</p>
<ul>
<li><p>R0-R30通用寄存器</p>
<p>每个寄存器最多可以存取一个64位大小的数。以x0-x30形式使用时是64位的，以w0-w30形式使用时是32位的。</p>
<p>其中，R0-R7作为函数的参数，R0保存函数的返回值</p>
<p>其中，R8寄存器用来保存子程序的返回值</p>
<p>其中，R29又称FP寄存器(frame point)，主要用来保存栈帧（栈底）指针；</p>
<p>其中，R30又称LR寄存器(link register)，主要用来保存函数返回地址</p>
</li>
<li><p>SP：栈顶指针</p>
</li>
<li><p>PC：类似于8086汇编中的IP寄存器，用来记录当前执行的指令地址</p>
</li>
<li><p>CPSR：状态寄存器，用来标记运算各种标记</p>
</li>
</ul>
<h3 id="指令集"><a href="#指令集" class="headerlink" title="指令集"></a>指令集</h3><ul>
<li><p>MOV 指令</p>
<p>mov x0, x1：把寄存器r1的值赋给寄存器r0</p>
<p>mov w0, #0x1122：把0x1122写进r1的低16位</p>
<p>movk   w0, #0x3344, lsl #16：0x3344作为w0的16-32位值</p>
</li>
<li><p>ADD 加法指令</p>
<p>ADD{条件}{S} 目的寄存器，操作数 1，操作数 2；指令用于把两个操作数相加，并将结果存放到目的寄存器中</p>
<p>ADD x0，x1，x2： x0 = x1 + x2<br> ADD x0，x1，#256：x0 = x1 + 256<br> ADD x0，x2，x3，LSL#1：x0 = x2 + x3&lt;&lt;1</p>
</li>
<li><p>SUB 减法指令</p>
<p>SUB{条件}{S} 目的寄存器，操作数 1，操作数 2</p>
</li>
<li><p>AND 逻辑与指令</p>
<p>AND{条件}{S} 目的寄存器，操作数 1，操作数 2</p>
</li>
<li><p>ORR 逻辑或指令</p>
<p>ORR{条件}{S} 目的寄存器，操作数 1，操作数 2</p>
</li>
<li><p>EOR 逻辑异或指令</p>
<p>ORR{条件}{S} 目的寄存器，操作数 1，操作数 2</p>
</li>
<li><p>LDR 存储器到寄存器的数据传输指令</p>
<p>LDR{条件} 目的寄存器，&lt;存储器地址&gt;</p>
</li>
<li><p>STR 寄存器到存储器的数据传输指令</p>
<p>STR{条件} 源寄存器，&lt;存储器地址&gt;</p>
</li>
<li><p>LDP 存储器连续读两个单元到两个寄存器</p>
<p>LDP 寄存器1， 寄存器2，&lt;存储器地址&gt;</p>
</li>
<li><p>STP 把两个寄存器的值连续放在某个内存地址后</p>
<p>STP 寄存器1， 寄存器2，&lt;存储器地址&gt;</p>
</li>
<li><p>CMP 比较指令</p>
<p>CMP{条件} 操作数 1，操作数 2</p>
<p>CMP 指令用于把一个寄存器的内容和另一个寄存器的内容或立即数进行比较，同时更新 CPSR 中 </p>
<p>条件标志位的值。该指令进行一次减法运算，但不存储结果，只更改条件标志位。标志位表示的是 操作数 1 与操作数 2 的关系(大、小、相等) 。</p>
</li>
<li><p>B 跳转指令</p>
<p>把要跳转的指令地址赋给PC寄存器</p>
</li>
<li><p>BL带返回地址的跳转指令</p>
<p>把要跳转的指令地址赋给PC寄存器，同时把下一个指令地址(返回地址)赋给LR寄存器</p>
</li>
<li><p>RET 子程序退出返回指令</p>
</li>
</ul>
<p><strong><em>在后面学习中有遇到其他指令会更新</em></strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/21/从汇编层面分析函数调用/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DevHuangjb">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="黄锦标的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/21/从汇编层面分析函数调用/" itemprop="url">从汇编层面分析函数调用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-03-21T17:30:53+08:00">
                2019-03-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这篇文章将探讨：</p>
<ul>
<li>函数调用如何返回</li>
<li>函数返回值底层实现</li>
<li>函数参数传递底层实现</li>
<li>函数调用堆栈平衡</li>
</ul>
<p>你需要知道：</p>
<ul>
<li>pc：程序计数器，记录当前执行的代码地址，对其赋值会跳转到对应的地址执行</li>
<li>lr (r30)：连接寄存器，当执行ret指令时，lr寄存器的值会赋给pc寄存器</li>
<li>fp (r29)：frame point寄存器，用来保存栈底指针</li>
<li>sp：stack point寄存器，用来保存栈顶指针</li>
<li>通用寄存器r0-r7作为函数调用的参数传递，如果参数大于8个就用栈空间来辅助</li>
<li>通用寄存器r0通常作为函数返回值的中转站</li>
</ul>
<h4 id="函数调用如何返回？"><a href="#函数调用如何返回？" class="headerlink" title="函数调用如何返回？"></a>函数调用如何返回？</h4><p>写一个最简单的没有传递参数，没有返回值的函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">void test()&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    </span><br><span class="line">    test();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来看看这个简单调用在汇编层面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">TestStack`main:</span><br><span class="line">    0x10000e920 &lt;+0&gt;:  sub    sp, sp, #0x20             ; =0x20 </span><br><span class="line">    0x10000e924 &lt;+4&gt;:  stp    x29, x30, [sp, #0x10]</span><br><span class="line">    0x10000e928 &lt;+8&gt;:  add    x29, sp, #0x10            ; =0x10 </span><br><span class="line">    0x10000e92c &lt;+12&gt;: stur   wzr, [x29, #-0x4]</span><br><span class="line">    0x10000e930 &lt;+16&gt;: str    w0, [sp, #0x8]</span><br><span class="line">    0x10000e934 &lt;+20&gt;: str    x1, [sp]</span><br><span class="line">    </span><br><span class="line">-&gt;  0x10000e938 &lt;+24&gt;: bl     0x10000e91c               ; test at main.m:12</span><br><span class="line">    0x10000e93c &lt;+28&gt;: mov    w0, #0x0</span><br><span class="line">    </span><br><span class="line">    0x10000e940 &lt;+32&gt;: ldp    x29, x30, [sp, #0x10]</span><br><span class="line">    0x10000e944 &lt;+36&gt;: add    sp, sp, #0x20             ; =0x20 </span><br><span class="line">    0x10000e948 &lt;+40&gt;: ret    </span><br><span class="line">    </span><br><span class="line">TestStack`test:</span><br><span class="line">-&gt;  0x10008691c &lt;+0&gt;: ret </span><br><span class="line"></span><br><span class="line"> ********************分析***********************</span><br><span class="line"> 把断点打在‘bl 0x10000e91c’</span><br><span class="line"> (lldb) register read</span><br><span class="line">        lr = 0x00000001993968b8  libdyld.dylib`start + 4</span><br><span class="line">        pc = 0x00000001000f6938  TestStack`main + 24 at main.m:16</span><br><span class="line"> (lldb) si</span><br><span class="line"> (lldb) register read</span><br><span class="line">General Purpose Registers:</span><br><span class="line">        lr = 0x00000001000f693c  TestStack`main + 28 at main.m:16</span><br><span class="line">        pc = 0x00000001000f691c  TestStack`test at main.m:12</span><br><span class="line"> </span><br><span class="line"> 可以看出执行‘bl 0x10000e91c’后，pc寄存器被赋值0x00000001000f691c,程序跳转到test函数执行</span><br><span class="line"> lr寄存器被赋值0x00000001000f693c，而这个地址正好是main函数里面‘bl 0x10000e91c’的下一条指令</span><br><span class="line"> 所以在test函数里面执行ret指令后，lr寄存器的值赋给pc寄存器实现函数调用的返回。</span><br></pre></td></tr></table></figure>
<h4 id="函数如何把返回值返回给调用者？"><a href="#函数如何把返回值返回给调用者？" class="headerlink" title="函数如何把返回值返回给调用者？"></a>函数如何把返回值返回给调用者？</h4><p>改一下test函数，让它简单的返回一个值，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int test()&#123;</span><br><span class="line">    return 10;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    int result = test();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来看看在汇编层面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">TestStack`main:</span><br><span class="line">    0x100076918 &lt;+0&gt;:  sub    sp, sp, #0x30             ; =0x30 </span><br><span class="line">    0x10007691c &lt;+4&gt;:  stp    x29, x30, [sp, #0x20]</span><br><span class="line">    0x100076920 &lt;+8&gt;:  add    x29, sp, #0x20            ; =0x20 </span><br><span class="line">    0x100076924 &lt;+12&gt;: stur   wzr, [x29, #-0x4]</span><br><span class="line">    0x100076928 &lt;+16&gt;: stur   w0, [x29, #-0x8]</span><br><span class="line">    0x10007692c &lt;+20&gt;: str    x1, [sp, #0x10]</span><br><span class="line">    </span><br><span class="line">-&gt;  0x100076930 &lt;+24&gt;: bl     0x100076910               ; test at main.m:11</span><br><span class="line">    0x100076934 &lt;+28&gt;: mov    w8, #0x0</span><br><span class="line">    0x100076938 &lt;+32&gt;: str    w0, [sp, #0xc]</span><br><span class="line">    0x10007693c &lt;+36&gt;: mov    x0, x8</span><br><span class="line">    </span><br><span class="line">    0x100076940 &lt;+40&gt;: ldp    x29, x30, [sp, #0x20]</span><br><span class="line">    0x100076944 &lt;+44&gt;: add    sp, sp, #0x30             ; =0x30 </span><br><span class="line">    0x100076948 &lt;+48&gt;: ret    </span><br><span class="line">    </span><br><span class="line">TestStack`test:</span><br><span class="line">-&gt;  0x100076910 &lt;+0&gt;: mov    w0, #0xa</span><br><span class="line">    0x100076914 &lt;+4&gt;: ret   </span><br><span class="line">    </span><br><span class="line">********************分析***********************</span><br><span class="line">我们在test函数里面简单的返回了10</span><br><span class="line">在汇编层面，‘mov w0, #0xa’把0xa赋值给x0寄存器的低32位</span><br><span class="line">在子程序执行返回后，调用函数通过读取x0寄存器的值拿到子程序的返回值，比如main函数里面‘str w0, [sp, #0xc]’就是把w0寄存器的值赋给局部变量</span><br></pre></td></tr></table></figure>
<h4 id="函数如何实现参数的传递？"><a href="#函数如何实现参数的传递？" class="headerlink" title="函数如何实现参数的传递？"></a>函数如何实现参数的传递？</h4><p>再一次修改test函数如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void test(int para1, int para2, int para3, int para4, int para5, int para6, int para7, int para8, int para9)&#123;</span><br><span class="line">    int a = 8;</span><br><span class="line">    a = a + para1 + para2 + para3 + para4 + para5 + para6 + para7 + para8 + para9;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    test(1,2,3,4,5,6,7,8,9);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来看看在汇编层面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">TestStack`main:</span><br><span class="line">    0x1000be8ec &lt;+0&gt;:  sub    sp, sp, #0x30             ; =0x30 </span><br><span class="line">    0x1000be8f0 &lt;+4&gt;:  stp    x29, x30, [sp, #0x20]</span><br><span class="line">    0x1000be8f4 &lt;+8&gt;:  add    x29, sp, #0x20            ; =0x20 </span><br><span class="line">    0x1000be8f8 &lt;+12&gt;: orr    w8, wzr, #0x1							;1赋给r8</span><br><span class="line">    0x1000be8fc &lt;+16&gt;: orr    w9, wzr, #0x2							;2赋给r9</span><br><span class="line">    0x1000be900 &lt;+20&gt;: orr    w2, wzr, #0x3							;3赋给r2</span><br><span class="line">    0x1000be904 &lt;+24&gt;: orr    w3, wzr, #0x4							;4赋给r3</span><br><span class="line">    0x1000be908 &lt;+28&gt;: mov    w4, #0x5									;5赋给r4</span><br><span class="line">    0x1000be90c &lt;+32&gt;: orr    w5, wzr, #0x6							;6赋给r5</span><br><span class="line">    0x1000be910 &lt;+36&gt;: orr    w6, wzr, #0x7							;7赋给r6</span><br><span class="line">    0x1000be914 &lt;+40&gt;: orr    w7, wzr, #0x8							;8赋给r7</span><br><span class="line">    0x1000be918 &lt;+44&gt;: mov    w10, #0x9									;9赋给r10</span><br><span class="line">    0x1000be91c &lt;+48&gt;: stur   wzr, [x29, #-0x4]</span><br><span class="line">    0x1000be920 &lt;+52&gt;: stur   w0, [x29, #-0x8]</span><br><span class="line">    0x1000be924 &lt;+56&gt;: str    x1, [sp, #0x10]</span><br><span class="line">    0x1000be928 &lt;+60&gt;: mov    x0, x8										;r8(值为1)赋给r0</span><br><span class="line">    0x1000be92c &lt;+64&gt;: mov    x1, x9										;r8(值为2)赋给r0</span><br><span class="line">    0x1000be930 &lt;+68&gt;: str    w10, [sp]									;把r10(值为9)的值入栈，</span><br><span class="line">    ;在跳转到test函数前：r0-r7响应的被复制1-8，</span><br><span class="line">    0x1000be934 &lt;+72&gt;: bl     0x1000be860               ; test at main.m:11</span><br><span class="line">    0x1000be938 &lt;+76&gt;: mov    w8, #0x0</span><br><span class="line">    0x1000be93c &lt;+80&gt;: mov    x0, x8</span><br><span class="line">    0x1000be940 &lt;+84&gt;: ldp    x29, x30, [sp, #0x20]</span><br><span class="line">    0x1000be944 &lt;+88&gt;: add    sp, sp, #0x30             ; =0x30 </span><br><span class="line">    0x1000be948 &lt;+92&gt;: ret  </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">TestStack`test:</span><br><span class="line">    0x1000be860 &lt;+0&gt;:   sub    sp, sp, #0x30             ; =0x30 </span><br><span class="line">    0x1000be864 &lt;+4&gt;:   ldr    w8, [sp, #0x30]			;main函数把para9入栈，这里把para9的值从栈空间读出来赋给r8			</span><br><span class="line">-&gt;  0x1000be868 &lt;+8&gt;:   orr    w9, wzr, #0x8        ;局部变量‘a=8’，r9=8</span><br><span class="line">    0x1000be86c &lt;+12&gt;:  str    w0, [sp, #0x2c]			;r0(para1)的值入栈</span><br><span class="line">    0x1000be870 &lt;+16&gt;:  str    w1, [sp, #0x28]			;r1(para2)的值入栈</span><br><span class="line">    0x1000be874 &lt;+20&gt;:  str    w2, [sp, #0x24]			;r2(para3)的值入栈</span><br><span class="line">    0x1000be878 &lt;+24&gt;:  str    w3, [sp, #0x20]			;r3(para4)的值入栈</span><br><span class="line">    0x1000be87c &lt;+28&gt;:  str    w4, [sp, #0x1c]			;r4(para5)的值入栈</span><br><span class="line">    0x1000be880 &lt;+32&gt;:  str    w5, [sp, #0x18]			;r5(para6)的值入栈</span><br><span class="line">    0x1000be884 &lt;+36&gt;:  str    w6, [sp, #0x14]			;r5(para7)的值入栈</span><br><span class="line">    0x1000be888 &lt;+40&gt;:  str    w7, [sp, #0x10]			;r7(para8)的值入栈</span><br><span class="line">    0x1000be88c &lt;+44&gt;:  str    w9, [sp, #0xc]				;局部变量a入栈</span><br><span class="line">    0x1000be890 &lt;+48&gt;:  ldr    w9, [sp, #0xc]				;从栈空间取出局部变量的值</span><br><span class="line">    0x1000be894 &lt;+52&gt;:  ldr    w0, [sp, #0x2c]			;从栈空间取出para1的值</span><br><span class="line">    0x1000be898 &lt;+56&gt;:  add    w9, w9, w0						;加法运算：局部变量a = a + para1</span><br><span class="line">    0x1000be89c &lt;+60&gt;:  ldr    w0, [sp, #0x28]			;从栈空间取出para2的值</span><br><span class="line">    0x1000be8a0 &lt;+64&gt;:  add    w9, w9, w0						;加法运算：局部变量a = a + para2</span><br><span class="line">    0x1000be8a4 &lt;+68&gt;:  ldr    w0, [sp, #0x24]			;......以下操作一样</span><br><span class="line">    0x1000be8a8 &lt;+72&gt;:  add    w9, w9, w0</span><br><span class="line">    0x1000be8ac &lt;+76&gt;:  ldr    w0, [sp, #0x20]</span><br><span class="line">    0x1000be8b0 &lt;+80&gt;:  add    w9, w9, w0</span><br><span class="line">    0x1000be8b4 &lt;+84&gt;:  ldr    w0, [sp, #0x1c]</span><br><span class="line">    0x1000be8b8 &lt;+88&gt;:  add    w9, w9, w0</span><br><span class="line">    0x1000be8bc &lt;+92&gt;:  ldr    w0, [sp, #0x18]</span><br><span class="line">    0x1000be8c0 &lt;+96&gt;:  add    w9, w9, w0</span><br><span class="line">    0x1000be8c4 &lt;+100&gt;: ldr    w0, [sp, #0x14]</span><br><span class="line">    0x1000be8c8 &lt;+104&gt;: add    w9, w9, w0</span><br><span class="line">    0x1000be8cc &lt;+108&gt;: ldr    w0, [sp, #0x10]</span><br><span class="line">    0x1000be8d0 &lt;+112&gt;: add    w9, w9, w0</span><br><span class="line">    0x1000be8d4 &lt;+116&gt;: ldr    w0, [sp, #0x30]</span><br><span class="line">    0x1000be8d8 &lt;+120&gt;: add    w9, w9, w0</span><br><span class="line">    0x1000be8dc &lt;+124&gt;: str    w9, [sp, #0xc]</span><br><span class="line">    0x1000be8e0 &lt;+128&gt;: str    w8, [sp, #0x8]</span><br><span class="line">    0x1000be8e4 &lt;+132&gt;: add    sp, sp, #0x30             ; =0x30 </span><br><span class="line">    0x1000be8e8 &lt;+136&gt;: ret     </span><br><span class="line">    </span><br><span class="line">********************分析***********************</span><br><span class="line">从上面的分析过程可以看出，函数参数首先会使用通用寄存器r0-r7，当传递的参数超过8个的时候，会借助函数的栈空间来辅助实现参数的传递</span><br></pre></td></tr></table></figure>
<h4 id="函数调用的堆栈平衡？"><a href="#函数调用的堆栈平衡？" class="headerlink" title="函数调用的堆栈平衡？"></a>函数调用的堆栈平衡？</h4><p>我们知道，函数调用的时候，系统会为该函数分配一个栈空间，在函数执行结束后栈空间会被系统回收。那么，系统底层是如何实现这个机制的呢？</p>
<p>函数根据是否调用子函数分为：</p>
<ul>
<li>叶子函数(没有调用其他子函数)</li>
<li>非叶子函数(有调用其他子函数)</li>
</ul>
<h5 id="先来分析下叶子函数的堆栈平衡"><a href="#先来分析下叶子函数的堆栈平衡" class="headerlink" title="先来分析下叶子函数的堆栈平衡"></a>先来分析下叶子函数的堆栈平衡</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int sum (int a, int b) &#123;</span><br><span class="line">    return a+b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    int result = sum(4, 5);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>汇编：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">TestStack`main:</span><br><span class="line">    0x100062910 &lt;+0&gt;:  sub    sp, sp, #0x30             ; =0x30 </span><br><span class="line">    0x100062914 &lt;+4&gt;:  stp    x29, x30, [sp, #0x20]</span><br><span class="line">    0x100062918 &lt;+8&gt;:  add    x29, sp, #0x20            ; =0x20 </span><br><span class="line">    0x10006291c &lt;+12&gt;: orr    w8, wzr, #0x4</span><br><span class="line">    0x100062920 &lt;+16&gt;: mov    w9, #0x5</span><br><span class="line">    0x100062924 &lt;+20&gt;: stur   w0, [x29, #-0x4]</span><br><span class="line">    0x100062928 &lt;+24&gt;: str    x1, [sp, #0x10]</span><br><span class="line">    0x10006292c &lt;+28&gt;: mov    x0, x8</span><br><span class="line">    0x100062930 &lt;+32&gt;: mov    x1, x9</span><br><span class="line">    0x100062934 &lt;+36&gt;: bl     0x1000628f0               ; sum at main.m:11</span><br><span class="line">    0x100062938 &lt;+40&gt;: mov    w8, #0x0</span><br><span class="line">    0x10006293c &lt;+44&gt;: str    w0, [sp, #0xc]</span><br><span class="line">    0x100062940 &lt;+48&gt;: mov    x0, x8</span><br><span class="line">    0x100062944 &lt;+52&gt;: ldp    x29, x30, [sp, #0x20]</span><br><span class="line">    0x100062948 &lt;+56&gt;: add    sp, sp, #0x30             ; =0x30 </span><br><span class="line">    0x10006294c &lt;+60&gt;: ret   </span><br><span class="line">    </span><br><span class="line">TestStack`sum:</span><br><span class="line">		;sp = sp - 0x10，栈顶指针下移16个内存单元，也就是系统为sum函数开辟了16个字节的栈空间大小</span><br><span class="line">-&gt;  0x1000628f0 &lt;+0&gt;:  sub    sp, sp, #0x10         </span><br><span class="line">		;w0存的是函数参数‘int a’,下面把参数a 入栈</span><br><span class="line">    0x1000628f4 &lt;+4&gt;:  str    w0, [sp, #0xc]</span><br><span class="line">    ;w1存的是函数参数‘int b’,下面把参数b 入栈</span><br><span class="line">    0x1000628f8 &lt;+8&gt;:  str    w1, [sp, #0x8]</span><br><span class="line">    ;从栈空间中读出参数a的值，赋给w0</span><br><span class="line">    0x1000628fc &lt;+12&gt;: ldr    w0, [sp, #0xc]</span><br><span class="line">    ;从栈空间中读出参数b的值，赋给w1</span><br><span class="line">    0x100062900 &lt;+16&gt;: ldr    w1, [sp, #0x8]</span><br><span class="line">    ;w0 = a + b，函数返回，外部函数通过w0拿到计算值</span><br><span class="line">    0x100062904 &lt;+20&gt;: add    w0, w0, w1</span><br><span class="line">    ;栈顶指针上移16个内存单元，栈空间实现平衡。刚进入sum函数开辟的16个字节的栈空间被回收(看上去像是被回收，实际只是上移了栈顶指针，内存内容依旧存在，等到后面其他函数的栈空间分配时才会对这段栈空间内存进行设置)</span><br><span class="line">    0x100062908 &lt;+24&gt;: add    sp, sp, #0x10             ; =0x10 </span><br><span class="line">    0x10006290c &lt;+28&gt;: ret</span><br></pre></td></tr></table></figure>
<p>再来看看非叶子函数如何实现堆栈平衡</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int sum (int a, int b) &#123;</span><br><span class="line">    return a+b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test (int a, int b) &#123;</span><br><span class="line">    int c = sum(a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    test(4, 6);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>汇编：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">TestStack`main:</span><br><span class="line">		;register read读取main函数进来后:</span><br><span class="line">		;fp = 0x000000016fdf79e0</span><br><span class="line">		;sp = 0x000000016fdf79d0</span><br><span class="line">    0x100076914 &lt;+0&gt;:  sub    sp, sp, #0x20             ; =0x20 </span><br><span class="line">    0x100076918 &lt;+4&gt;:  stp    x29, x30, [sp, #0x10]</span><br><span class="line">    0x10007691c &lt;+8&gt;:  add    x29, sp, #0x10            ; =0x10 </span><br><span class="line">    0x100076920 &lt;+12&gt;: orr    w8, wzr, #0x4</span><br><span class="line">    0x100076924 &lt;+16&gt;: orr    w9, wzr, #0x6</span><br><span class="line">    0x100076928 &lt;+20&gt;: stur   w0, [x29, #-0x4]</span><br><span class="line">    0x10007692c &lt;+24&gt;: str    x1, [sp]</span><br><span class="line">    0x100076930 &lt;+28&gt;: mov    x0, x8</span><br><span class="line">    0x100076934 &lt;+32&gt;: mov    x1, x9</span><br><span class="line">    0x100076938 &lt;+36&gt;: bl     0x1000768e4               ; test at main.m:15</span><br><span class="line">    0x10007693c &lt;+40&gt;: mov    w8, #0x0</span><br><span class="line">    0x100076940 &lt;+44&gt;: mov    x0, x8</span><br><span class="line">    0x100076944 &lt;+48&gt;: ldp    x29, x30, [sp, #0x10]</span><br><span class="line">    0x100076948 &lt;+52&gt;: add    sp, sp, #0x20             ; =0x20 </span><br><span class="line">    0x10007694c &lt;+56&gt;: ret  </span><br><span class="line">    </span><br><span class="line">TestStack`test:</span><br><span class="line">		;fp = 0x000000016fdf79e0</span><br><span class="line">		;sp = sp - 0x20 = 0x000000016fdf79b0</span><br><span class="line">    0x1000768e4 &lt;+0&gt;:  sub    sp, sp, #0x20             ; =0x20 </span><br><span class="line">    ;现场保护，把main函数执行时的fp(x29),lr(x30)入栈保存：这两个寄存器关系到main函数执行时的栈底指针和main函数执行后的返回地址，很重要</span><br><span class="line">-&gt;  0x1000768e8 &lt;+4&gt;:  stp    x29, x30, [sp, #0x10]</span><br><span class="line">		;设置自己的fp(栈底指针)</span><br><span class="line">    0x1000768ec &lt;+8&gt;:  add    x29, sp, #0x10            ; =0x10 </span><br><span class="line">    0x1000768f0 &lt;+12&gt;: stur   w0, [x29, #-0x4]</span><br><span class="line">    0x1000768f4 &lt;+16&gt;: str    w1, [sp, #0x8]</span><br><span class="line">    0x1000768f8 &lt;+20&gt;: ldur   w0, [x29, #-0x4]</span><br><span class="line">    0x1000768fc &lt;+24&gt;: ldr    w1, [sp, #0x8]</span><br><span class="line">    ;跳转到sum函数</span><br><span class="line">    0x100076900 &lt;+28&gt;: bl     0x1000768c4               ; sum at main.m:11</span><br><span class="line">    ;sum函数把返回值放在r0寄存器，这边把返回值赋给局部变量‘int c’</span><br><span class="line">    0x100076904 &lt;+32&gt;: str    w0, [sp, #0x4]</span><br><span class="line">    ;恢复现场，把入栈保存的main函数fp,lr指针出栈恢复</span><br><span class="line">    0x100076908 &lt;+36&gt;: ldp    x29, x30, [sp, #0x10]</span><br><span class="line">    ;栈顶指针上移32个内存单元，栈空间实现平衡。</span><br><span class="line">    0x10007690c &lt;+40&gt;: add    sp, sp, #0x20             ; =0x20 </span><br><span class="line">    0x100076910 &lt;+44&gt;: ret   </span><br><span class="line">    </span><br><span class="line">TestStack`sum:</span><br><span class="line">-&gt;  0x1000768c4 &lt;+0&gt;:  sub    sp, sp, #0x10             ; =0x10 </span><br><span class="line">    0x1000768c8 &lt;+4&gt;:  str    w0, [sp, #0xc]</span><br><span class="line">    0x1000768cc &lt;+8&gt;:  str    w1, [sp, #0x8]</span><br><span class="line">    0x1000768d0 &lt;+12&gt;: ldr    w0, [sp, #0xc]</span><br><span class="line">    0x1000768d4 &lt;+16&gt;: ldr    w1, [sp, #0x8]</span><br><span class="line">    0x1000768d8 &lt;+20&gt;: add    w0, w0, w1</span><br><span class="line">    0x1000768dc &lt;+24&gt;: add    sp, sp, #0x10             ; =0x10 </span><br><span class="line">    0x1000768e0 &lt;+28&gt;: ret</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/20/记一个安装Charles证书的大坑/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DevHuangjb">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="黄锦标的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/20/记一个安装Charles证书的大坑/" itemprop="url">记一个安装Charles证书的大坑~</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-03-20T15:17:12+08:00">
                2019-03-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>今天在我个人的Mac上面安装charles并配置ssl证书的时候出现了一个问题，iphone device访问chls.pro/ssl下载证书的时候没有出现弹框，仅仅是以字符串的形式展示证书的密文:</p>
<p>“ - - - - BEGIN CERTIFICATE - - - - </p>
<p>sdfjsljdflsjaldjlsjlj</p>
<p>sljdfljsflj……</p>
<p>“ - - - - END CERTIFICATE - - - - “</p>
<p>同样的操作流程我在公司的电脑却能正常安装，不过公司的Charles已经装很久了我也不知道有没有遗漏什么。</p>
<p>二话不说，，上stackoverflow一通搜索。尼玛竟然没有类似的question！</p>
<p>当时我就有点生活不能自理，只能靠自己了。</p>
<p>各种尝试，各种排除法之后发现了问题所在：</p>
<p>Charles菜单栏 —&gt; Tool —&gt; Rewrite被使能了，这样请求证书文件<a href="http://www.charlesproxy.com/getssl时，请求头会添加：content-type:application/json;charset=UTF-8" target="_blank" rel="noopener">http://www.charlesproxy.com/getssl时，请求头会添加：content-type:application/json;charset=UTF-8</a></p>
<p>所以，把Rewrite disable掉，就能正常安装证书了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/12/iOS开发之：动态调试/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DevHuangjb">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="黄锦标的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/12/iOS开发之：动态调试/" itemprop="url">iOS开发之：动态调试</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-02-12T13:51:43+08:00">
                2019-02-12
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="首先，安利一个facebook的调试神器：-Chisel-。"><a href="#首先，安利一个facebook的调试神器：-Chisel-。" class="headerlink" title="首先，安利一个facebook的调试神器： Chisel 。"></a>首先，安利一个facebook的调试神器： <a href="https://github.com/facebook/chisel" target="_blank" rel="noopener">Chisel</a> 。</h3><h3 id="Xcode动态调试原理："><a href="#Xcode动态调试原理：" class="headerlink" title="Xcode动态调试原理："></a>Xcode动态调试原理：</h3><p>首先来了解几个术语：GCC，LLVM，GDB，LLDB：GCC和GDB属于编译器，LLVM和LLDB属于调试器</p>
<ul>
<li>Xcode编译器的发展历程：GCC —&gt; LLVM</li>
<li>Xcode调试器的发展历程：GDB —&gt; LLDB</li>
</ul>
<p>当Xcode识别到手机设备后，会自动将debugserver安装到iPhone上面：/Developer/usr/bin/debugserver。之后Xcode利用本身集成的调试器LLDB和debugserver交互，达到调试APP的目的。</p>
<h3 id="LLDB常用命令："><a href="#LLDB常用命令：" class="headerlink" title="LLDB常用命令："></a>LLDB常用命令：</h3><p>首先介绍下lldb命令的格式：</p>
<ul>
<li><p>help：</p>
<p>help:只输入help会列出lldb的所有命令，包括用户自定义的lldb命令集</p>
<p>help <command>: 某个命令的用法信息，比如help breakpoint</p>
<p>help <command> [subcommand] : 某个命令的子命令的用法，比如help breakpoint set</p>
</li>
<li><p>p、call、print、express四个命令等价，都是可以执行一个表达式</p>
<p>比如</p>
<p>可以p self.xxx来获取某个属性值</p>
<p>可以p self.view.backgroundColor = [UIColor redColor]，这样就可以随心所欲的执行自己想要的代码，免去反复的build操作</p>
</li>
<li><p>po</p>
<p>po和p的一个差别是p命令只能拿到对象的内存地址，po可以取得对象更详细的信息：比如NSArray和NSDictionary会打印内部的元素，UIVeiw会打印frame,layer等信息</p>
</li>
<li><p>thread backtrace : 快捷键bt</p>
<p>打印线程的堆栈信息</p>
</li>
<li><p>thread return [<expr>]：直接退出当前的函数调用栈</expr></p>
</li>
<li><p>thread continue<strong>􏰁、</strong>continue<strong>􏰁、</strong>c 􏰲􏰋􏰌􏲥􏲦􏰍􏰎：程序继续运行</p>
</li>
<li><p>thread stepover、next、n：单步运行，把子函数当做一个整体</p>
</li>
<li><p>thread step-in􏰁、step、s：􏳐􏳑􏰍􏰎􏰑􏳕􏰽􏲲􏰣􏰟􏱃􏲑􏲝􏲲􏰣􏰟单步运行，遇到子函数会跳进子函数</p>
</li>
<li><p>thread step-out、finish：执行完当前函数的所有代码，返回到上一个调用的函数 􏰲􏳐􏳑􏰍􏰎􏰑􏳕􏰽􏲲</p>
</li>
<li><p>watchpoint set variable 变量：当内存数据变化时触发断点</p>
</li>
<li><p>watchpoint list：列出内存断点列表</p>
</li>
<li><p>watchpoint enable 断点编号：使能断点</p>
</li>
<li><p>watchpoint disable 断点编号：使断点失效</p>
</li>
<li><p>watchpoint delete 断点编号：删除断点</p>
</li>
<li><p>image lookup -address 内存地址：查找这个地址具体对应的文件位置</p>
</li>
<li><p>image lookup -name methodName: 查找一个方法或者符号的信息，比如所在文件位置等</p>
</li>
<li><p>image lookup -type className ：打印某个类的信息</p>
</li>
</ul>
<p>更多的lldb命令请参考官方文档：<a href="http://lldb.llvm.org/lldb-gdb.html" target="_blank" rel="noopener">文档</a></p>
<h3 id="lldb汇编层面常用调试命令"><a href="#lldb汇编层面常用调试命令" class="headerlink" title="lldb汇编层面常用调试命令"></a>lldb汇编层面常用调试命令</h3><ul>
<li><p>register read 读取所以寄存器的值</p>
</li>
<li><p>register write w0 0x8 把值写进寄存器</p>
</li>
<li><p>x命令读取内存内容</p>
<p>命令格式：x/nfu obj</p>
<p>n：代表要读取几个单元</p>
<p>f：显示方式，有如下值</p>
<p>| 参数 | 含义                       |<br>| —- | ————————– |<br>| x    | 按十六进制格式显示变量     |<br>| d    | 按十进制格式显示变量       |<br>| u    | 按十进制格式显示无符号整型 |<br>| o    | 按八进制格式显示变量       |<br>| t    | 按二进制格式显示变量       |<br>| a    | 按十六进制格式显示变量     |<br>| i    | 指令地址格式               |<br>| c    | 按字符格式显示变量         |<br>| f    | 按浮点数格式显示变量       |</p>
<p>u：表示一个单元的长度</p>
<p>| 参数 | 含义             |<br>| —- | —————- |<br>| b    | 按单字节分段输出 |<br>| h    | 按双字节分段输出 |<br>| w    | 按四字节分段输出 |<br>| g    | 按八字节分段输出 |</p>
<p>obj：表示内存地址，可以是变量名，也可以是内存地址。</p>
</li>
</ul>
<h3 id="Chisel"><a href="#Chisel" class="headerlink" title="Chisel"></a>Chisel</h3><p>Chisel是facebook开源的辅助动态调试iOS APP的LLDB命令集合。详细文档参考 <a href="https://github.com/facebook/chisel/wiki" target="_blank" rel="noopener">github wiki</a></p>
<p>下面我举几个比较常用：</p>
<ul>
<li><p><strong>bmessage</strong>：这个命令可以指定某个方法打断点，即使你的代码没有重写这个方法，bmessage也会遍历继承链去查找。</p>
<p>用法： <strong>bmessage -[ViewController viewWillAppear:]</strong></p>
</li>
<li><p><strong>border</strong>：给指定的view添加边框</p>
<p>用法：<strong>border -c red -w 5 self.redView</strong> 或者 <strong>border –color=red —width=5 self.redView</strong></p>
<p>等价于lldb命令：<strong>p self.redView.layer.borderColor = [UIColor redColor].CGColor</strong> &amp;&amp; <strong>p self.redView.layer.borderWidth = 5</strong></p>
<p>怎么样？是不是爽多了！</p>
</li>
</ul>
<ul>
<li><strong>unborder</strong>：去除view的边框。</li>
<li><p><strong>caflush</strong>：重新刷新UI界面</p>
</li>
<li><p><strong>flicker</strong>：闪烁指定的view，可以快速定位到指定view的位置</p>
</li>
<li><strong>fv</strong>： fv <classnameregex>，指定一个ClassName的正则表达式，fv会打印出整个视图层级中subview的类名符合正则表达式的对象</classnameregex></li>
<li><strong>fvc</strong>：fvc [–name=classNameRegex] [–view=view]，两个参数只能指定其中一个。根据类名或者指定view来查找对应的控制器实例对象。</li>
<li><strong>hide &amp; show</strong>：显示或隐藏指定的view</li>
<li><strong>mwarning</strong>：模拟发出一个内存警告</li>
<li><strong>pbundlepath</strong>：打印budler路径</li>
<li><strong>pdocspath</strong>：打印沙盒路径。pdocspath -o，打印路径的同时在Finder中打开</li>
<li><strong>pinternals</strong>：打印对象内部的成员变量</li>
<li><p><strong>pjson</strong>：打印json数据，lldb的po指令显示不了中文，pjson可以显示中文</p>
</li>
<li><p><strong>pmethods</strong>：打印某个类的方法</p>
<p>用法：<strong>pmethods -a -i -c -n IndexMainController</strong> (-a：把方法函数指针打印出来，-i：打印实例方法，-c：打印类方法)</p>
</li>
<li><p><strong>pvc</strong>：打印当前控制器的层级结构</p>
</li>
<li><p><strong>pviews</strong>：pviews self.view: 打印self.view的subviews</p>
</li>
<li><p><strong>slowanim</strong> &amp;&amp; <strong>unslowanim</strong>：这两个命令在调试动画的时候非常。有用用法：slowanim <speed>,speed默认是0.1。</speed></p>
</li>
<li><p><strong>taplog</strong>：输入taplog，然后点击屏幕上面的view，会把这个view的信息打印出来</p>
</li>
<li><p><strong>visualize</strong>：visualize <target> (target可以是： UIImage, CGImageRef, UIView, or CALayer)，调用系统的图片查看器展示对应的对象。</target></p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/25/iOS底层原理：NSDictionary原理/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DevHuangjb">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="黄锦标的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/25/iOS底层原理：NSDictionary原理/" itemprop="url">iOS底层原理：NSDictionary原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-01-25T22:55:31+08:00">
                2019-01-25
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>NSDictionary（字典）是使用 hash表来实现key和value之间的映射和存储的。</p>
</blockquote>
<h3 id="关于hash表"><a href="#关于hash表" class="headerlink" title="关于hash表"></a>关于hash表</h3><p>想想一下，我们有一个数组，数组长度是100个，现在的需求是：给出这个数组是否包含一个对象obj？</p>
<p>如果这是个无序的数组，那么我们只能用遍历的方法来查找是否包含这个对象obj了。这是我们的时间复杂度就是O(n)。</p>
<p>这种查找效率是很低的，所以hash表应运而生。</p>
<p>hash表其实也是一个数组，区别数组的地方是它会建立 <strong><em>存储的值</em></strong> 到 <strong><em>存储的下标</em></strong> 索引的一个映射，也就是散列函数。</p>
<p>我们来举一个通俗易懂的例子：</p>
<p>现在我们有个hash表，表长度count = 16，现在我们依次把3，12，24，30依次存入hash表中。</p>
<p>首先我们来约定一个简单的映射关系：存储的索引下表(index) = 存储值(value) % hash表长度(count)；</p>
<p><strong><em>[注：实际的映射并不是简单的存储值，而是经过计算得到的hash值]</em></strong></p>
<p>算下来hash表的存储分布是这样的：hash[3] = 3、hash[12] = 12、hash[8] = 24、hash[14] = 30</p>
<p>还是一样的需求，当我们给出24的时候，求出hash表中是否存有24？</p>
<p>此时，按照原先约定的映射关系：index = 24 % 16 = 8，然后我们在hash[8]查询等于24。这样，通过数组需要O(n)的时间复杂度，通过hash表只需要O(1)；</p>
<h4 id="散列碰撞"><a href="#散列碰撞" class="headerlink" title="散列碰撞"></a>散列碰撞</h4><p>上面提到的hash表在存入3，12，24，30后，如果要面临存入19呢？</p>
<p>此时index = 19 % 16 = 3，而之前hash[3] 已经存入了3这个值了！这种情况就是发送了散列碰撞。</p>
<p>此时，我们可以改进一下我们的hash表，让它存储的是一个链表。这样发送散列碰撞的元素就可以以链表的形式共处在hash表的某一个下标位置了。</p>
<p><img src="/2019/01/25/iOS底层原理：NSDictionary原理/hash存储.jpg" alt="hash存储"></p>
<p>所以，只要发生了散列碰撞，我们查找的时间复杂度就不能像O(1)这么小了，因为还要考虑链表的查找时间复杂度O(n)。</p>
<h4 id="负载因子、自动扩容"><a href="#负载因子、自动扩容" class="headerlink" title="负载因子、自动扩容"></a>负载因子、自动扩容</h4><p>哈希表还有一个重要的属性: 负载因子(load factor)，它用来衡量哈希表的 <strong>空/满</strong> 程度</p>
<blockquote>
<p>负载因子 = 总键值对数 / 箱子个数</p>
</blockquote>
<p>当存储的元素个数越来越多，在hash表长度不变的前提下，发生散列碰撞的概率就会变大，查找性能就变低了。所以当负载因子达到一定的值，hash表会进行自动扩容。</p>
<p>哈希表在自动扩容时，一般会扩容出一倍的长度。元素的hash值不变，对哈希表长度取模的值也会改变，所以元素的存储位置也要相对应重新计算，这个过程也称为重哈希(rehash)。</p>
<p>哈希表的扩容并不总是能够有效解决负载因子过大而引起的查询性能变低的问题。假设所有 key 的哈希值都一样，那么即使扩容以后他们的位置也不会变化。虽然负载因子会降低，但实际存储在每个箱子中的链表长度并不发生改变，因此也就不能提高哈希表的查询性能。所以，设计一个合理有效的散列函数显得相当的有必要，这个合理有效应该体现在映射之后各元素均匀的分布在hash表当中。</p>
<h3 id="说回NSDictionary"><a href="#说回NSDictionary" class="headerlink" title="说回NSDictionary"></a>说回NSDictionary</h3><p>字典是开发中最常见的集合了。当我们调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)setObject:(ObjectType)anObject forKey:(KeyType &lt;NSCopying&gt;)aKey;</span><br></pre></td></tr></table></figure>
<p>我们来探究下字典存储键值对的过程，有两个方法对hash存储起着关键的影响：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (NSUInteger)hash;</span><br><span class="line">- (BOOL)isEqual:(id)object;</span><br></pre></td></tr></table></figure>
<p>demo1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">@interface KeyType : NSObject&lt;NSCopying&gt;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, copy) NSString *keyName;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithKeyName:(NSString *)keyName;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation KeyType</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithKeyName:(NSString *)keyName &#123;</span><br><span class="line">    if (self = [super init]) &#123;</span><br><span class="line">       _keyName  = keyName;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//直接电影父类hash方法</span><br><span class="line">- (NSUInteger)hash &#123;</span><br><span class="line">    NSLog(@&quot;hash func&quot;);</span><br><span class="line">    return [super hash];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//直接调用父类isEqual方法</span><br><span class="line">- (BOOL)isEqual:(id)object &#123;</span><br><span class="line">    NSLog(@&quot;isEqual func&quot;);</span><br><span class="line">    return [super isEqual:object];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (nonnull id)copyWithZone:(nullable NSZone *)zone &#123;</span><br><span class="line">    NSLog(@&quot;copy funcr&quot;);</span><br><span class="line">    KeyType *key = [[KeyType alloc] initWithKeyName:self.keyName];</span><br><span class="line">    return key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    NSMutableDictionary *dic = [NSMutableDictionary new];</span><br><span class="line">    KeyType *key1 = [[KeyType alloc] initWithKeyName:@&quot;key1&quot;];</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;for value&quot;);</span><br><span class="line">    NSLog(@&quot;%@&quot;,[key1 valueForKey:@&quot;retainCount&quot;]);</span><br><span class="line">    [dic setObject:key1 forKey:@&quot;valueKey&quot;];</span><br><span class="line">    NSLog(@&quot;%@&quot;,[key1 valueForKey:@&quot;retainCount&quot;]);</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;for key&quot;);</span><br><span class="line">    [dic setObject:@&quot;object1&quot; forKey:key1];</span><br><span class="line">    NSLog(@&quot;%@&quot;,[key1 valueForKey:@&quot;retainCount&quot;]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">控制台打印：</span><br><span class="line">for value</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">for key</span><br><span class="line">hash func</span><br><span class="line">copy func</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<p>分析：</p>
<ul>
<li>key1作为键值对的value时，不会去计算hash值，dictionary会对key1进行一次强引用。</li>
<li>key1作为键值对的key时，会先去计算hash值，然后[key1 copy]拷贝一份key1和value存储在字典中</li>
</ul>
<p>下面来看第二个测试用例：Demo2</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    NSMutableDictionary *dic = [NSMutableDictionary new];</span><br><span class="line">    KeyType *key1 = [[KeyType alloc] initWithKeyName:@&quot;key1&quot;];</span><br><span class="line">    [dic setObject:@&quot;object1&quot; forKey:key1];</span><br><span class="line">    NSLog(@&quot;%ld&quot;,dic.count);</span><br><span class="line">    NSLog(@&quot;%@&quot;,dic[key1]);</span><br><span class="line">&#125;</span><br><span class="line">控制台打印：</span><br><span class="line">hash func</span><br><span class="line">copy func</span><br><span class="line">1</span><br><span class="line">hash func</span><br><span class="line">isEqual func</span><br><span class="line">(null)</span><br></pre></td></tr></table></figure>
<p>dic.count = 1，说明{key1 : @”object1”}已经存储进去了。然而通过这个key去获取竟然返回null？</p>
<p>从打印也可以看出来，现在isEqual函数开始被调用了。</p>
<p>分析：</p>
<ul>
<li><p>dic[key1]作为key去字典中查询value时，也会先计算hash值，来确定在hash表中的存储下标位置</p>
</li>
<li><p>因为存储散列碰撞的可能，所以找到下标后，会调用isEqual方法来匹配链表上面的各个元素之间的key值。当isEqual:返回YES时，会把对应的value返回。</p>
</li>
<li><p>调用父类的isEqual，NSObject的- (BOOL)isEqual:(id)object比较的是内存地址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)isEqual:(id)object &#123;</span><br><span class="line">    return self == object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>根据demo1的分析，key1作为键值对的key时，会拷贝一份存储到字典中。既然是拷贝，那当然和原始对象不是同一个对象，所以- (BOOL)isEqual:(id)object返回NO。所以我们在链表的查询中找不到对应的key，最终返回null</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//我们可以强制重写KeyType的isEqual:返回YES，demo2的返回值就不是null了</span><br><span class="line">- (BOOL)isEqual:(id)object &#123;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>由此可见，当一个类需要作为字典的key，重写hash和isEqual:方法显得很有必要。</p>
<h3 id="重写hash方法"><a href="#重写hash方法" class="headerlink" title="重写hash方法"></a>重写hash方法</h3><h5 id="为什么要重写hash方法？"><a href="#为什么要重写hash方法？" class="headerlink" title="为什么要重写hash方法？"></a>为什么要重写hash方法？</h5><p>我们先来看看NSObject的hash方法返回什么：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">KeyType *key1 = [[KeyType alloc] initWithKeyName:@&quot;key1&quot;];</span><br><span class="line">NSLog(@&quot;%p&quot;,key1);</span><br><span class="line">NSLog(@&quot;%lx&quot;,[key1 hash]);</span><br><span class="line">控制台打印：</span><br><span class="line">0x600000640610</span><br><span class="line">600000640610</span><br></pre></td></tr></table></figure>
<p>由此可见，NSObject是把对象的内存地址作为hash值返回。</p>
<p>以内存地址作为hash可以保证唯一性，但是这样好不好？</p>
<p>这样不好！</p>
<p>来看下这个场景：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">@interface KeyType : NSObject&lt;NSCopying&gt;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, copy) NSString *keyName;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithKeyName:(NSString *)keyName;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation KeyType</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithKeyName:(NSString *)keyName &#123;</span><br><span class="line">    if (self = [super init]) &#123;</span><br><span class="line">       _keyName  = keyName;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSUInteger)hash &#123;</span><br><span class="line">    return [super hash];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//强制返回YES</span><br><span class="line">- (BOOL)isEqual:(id)object &#123;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (nonnull id)copyWithZone:(nullable NSZone *)zone &#123;</span><br><span class="line">    KeyType *key = [[KeyType alloc] initWithKeyName:self.keyName];</span><br><span class="line">    return key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    NSMutableDictionary *dic = [NSMutableDictionary new];</span><br><span class="line">    KeyType *key1 = [[KeyType alloc] initWithKeyName:@&quot;key1&quot;];</span><br><span class="line">    KeyType *key2 = [[KeyType alloc] initWithKeyName:@&quot;key1&quot;];</span><br><span class="line">    [dic setObject:@&quot;object1&quot; forKey:key1];</span><br><span class="line">    NSLog(@&quot;%@&quot;,dic[key2]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很明显，最后打印是null。</p>
<p>但是在一般的业务场景，因为key1和key2的keyName属性都一样，所以应该被看为同一个key。</p>
<p>所以我们要重新hash方法。</p>
<h5 id="如何重写hash方法"><a href="#如何重写hash方法" class="headerlink" title="如何重写hash方法"></a>如何重写hash方法</h5><p>一个合理的hash方法要尽量让hash表中的元素均匀分布，来保证较高的查询性能。</p>
<p>如果两个对象可以被视为同一个对象，那么他们的hash值要一样。</p>
<p>mattt在文章<a href="https://nshipster.com/equality/" target="_blank" rel="noopener">Equality</a> 中给出了一个普遍的算法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (NSUInteger)hash &#123;</span><br><span class="line">    return [self.property1 hash] ^ [self.property2 hash] ^ [self.property3 hash];</span><br><span class="line">&#125;</span><br><span class="line">//假设对象有三个属性，那么对这三个属性分别算出hash值，然后进行异或运算</span><br></pre></td></tr></table></figure>
<p>Instagram在开源IGListKit的同时，鼓励这么写hash方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (NSUInteger)hash</span><br><span class="line">&#123;</span><br><span class="line">  NSUInteger subhashes[] = &#123;[self.property1 hash], [self.property2 hash], [self.property3 hash]&#125;;</span><br><span class="line">  NSUInteger result = subhashes[0];</span><br><span class="line">  for (int ii = 1; ii &lt; 3; ++ii) &#123;</span><br><span class="line">    unsigned long long base = (((unsigned long long)result) &lt;&lt; 32 | subhashes[ii]);</span><br><span class="line">    base = (~base) + (base &lt;&lt; 18);</span><br><span class="line">    base ^= (base &gt;&gt; 31);</span><br><span class="line">    base *=  21;</span><br><span class="line">    base ^= (base &gt;&gt; 11);</span><br><span class="line">    base += (base &lt;&lt; 6);</span><br><span class="line">    base ^= (base &gt;&gt; 22);</span><br><span class="line">    result = base;</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="重写isEqual"><a href="#重写isEqual" class="headerlink" title="重写isEqual:"></a>重写isEqual:</h3><p>如何写一个合理高效的判等方法？</p>
<ol>
<li>首先对内存地址进行判断，地址相等return YES;</li>
<li>进行判空处理，self == nil || object == nil ，return NO;</li>
<li>类型判断，![object isKindOfClass:[self class]] , return NO;</li>
<li>对对象的其他属性进行判断</li>
</ol>
<p>根据这四个步骤，我们可以发现，我们都是先判断时间开销最少的属性。所以对于第4个步骤，如果对象有很多属性，我们也要依照这个原则来！比如[self.array isEqual:other.array] &amp;&amp; self.intVal == other.intVal这种写法是不合理的，因为array的判等会去遍历元素，时间开销大。如果intVal不相等的话就可以直接return NO了，没必要进行数组的判等。应该这么写： self.intVal == other.intVal  &amp;&amp;  [self.array isEqual:other.array]</p>
<p>示例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)isEqual:(PersonModel *)object</span><br><span class="line">&#123;</span><br><span class="line">  if (self == object) &#123;</span><br><span class="line">    return YES;</span><br><span class="line">  &#125; else if (self == nil || object == nil || ![object isKindOfClass:[self class]]) &#123;</span><br><span class="line">    return NO;</span><br><span class="line">  &#125;</span><br><span class="line">  return</span><br><span class="line">    (_property1 == object-&gt;_property1 ? YES : [_property1 isEqual:object-&gt;_property1]) &amp;&amp;</span><br><span class="line">    (_property2 == object-&gt;_property2 ? YES : [_property2 isEqual:object-&gt;_property2]) &amp;&amp;</span><br><span class="line">    (_property3 == object-&gt;_property3 ? YES : [_property3 isEqual:object-&gt;_property3]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/21/SDWebImage解析之SDImageCache/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DevHuangjb">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="黄锦标的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/21/SDWebImage解析之SDImageCache/" itemprop="url">SDWebImage解析之SDImageCache</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-01-21T09:40:33+08:00">
                2019-01-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>我们知道移动端有三级缓存：远程的服务器，还有本地的内存缓存，硬盘缓存。SDImageCache的存在就是为了解决图片的本地缓存。SDImageCache是SDWebImage一个很重要的部分。为SDWebImage提供了以下功能：</p>
<ul>
<li><p>内存缓存，基于NSCache</p>
</li>
<li><p>异步的硬盘缓存，不会阻塞主线程</p>
</li>
<li><p>提供同步和异步两种方式来查询是否有缓存图片</p>
</li>
<li><p>提供同步和异步来获取缓存的图片</p>
</li>
<li><p>删除缓存图片</p>
</li>
</ul>
<h3 id="SDImageCacheConfig"><a href="#SDImageCacheConfig" class="headerlink" title="SDImageCacheConfig"></a>SDImageCacheConfig</h3><p>我们先来看看SDImageCacheConfig，SDImageCacheConfig是用来图片缓存的配置信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//SDImageCacheConfigExpireType定义的是以什么方式来计算图片的过期时间</span><br><span class="line">typedef NS_ENUM(NSUInteger, SDImageCacheConfigExpireType) &#123;</span><br><span class="line">    //图片最近访问的时间</span><br><span class="line">    SDImageCacheConfigExpireTypeAccessDate,</span><br><span class="line">    //默认：图片最近修改的时间</span><br><span class="line">    SDImageCacheConfigExpireTypeModificationDate</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>SDImageCacheConfig的配置属性和注释如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">@interface SDImageCacheConfig : NSObject</span><br><span class="line"></span><br><span class="line">//预解码图片，默认YES；</span><br><span class="line">//预解码图片可以提升性能，但会消耗太多的内存</span><br><span class="line">@property (assign, nonatomic) BOOL shouldDecompressImages;</span><br><span class="line"></span><br><span class="line">//取消iCloud备份</span><br><span class="line">@property (assign, nonatomic) BOOL shouldDisableiCloud;</span><br><span class="line"></span><br><span class="line">//是否禁用内存缓存</span><br><span class="line">@property (assign, nonatomic) BOOL shouldCacheImagesInMemory;</span><br><span class="line"></span><br><span class="line">//开启SDMemoryCache内部维护的一张图片弱引用表</span><br><span class="line">//好处：当收到内存警告，SDMemoryCache会移除图片的缓存,但是有些图片此时已经被一些诸如UIImageView强引用这，使用这个弱引用表就能访问到图片，避免后面再去query硬盘缓存</span><br><span class="line">@property (assign, nonatomic) BOOL shouldUseWeakMemoryCache;</span><br><span class="line"></span><br><span class="line">//硬盘图片读取的配置选项，默认是0</span><br><span class="line">@property (assign, nonatomic) NSDataReadingOptions diskCacheReadingOptions;</span><br><span class="line"></span><br><span class="line">//把图片存入硬盘的配置选项，默认NSDataWritingAtomic原子操作</span><br><span class="line">@property (assign, nonatomic) NSDataWritingOptions diskCacheWritingOptions;</span><br><span class="line"></span><br><span class="line">//图片最大的缓存时间，默认1星期</span><br><span class="line">@property (assign, nonatomic) NSInteger maxCacheAge;</span><br><span class="line"></span><br><span class="line">//最大的缓存大小，如果maxCacheSize&gt;0,在清除硬盘缓存的时候会先把缓存时间操作maxCacheAge的图片清除掉，然后再清除图片到总缓存大小在maxCacheSize * 0.5以下</span><br><span class="line">@property (assign, nonatomic) NSUInteger maxCacheSize;</span><br><span class="line"></span><br><span class="line">//硬盘缓存图片过期时间的计算方式，默认是最近修改的时间</span><br><span class="line">@property (assign, nonatomic) SDImageCacheConfigExpireType diskCacheExpireType;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>SDImageCacheConfig的初始化函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">static const NSInteger kDefaultCacheMaxCacheAge = 60 * 60 * 24 * 7; // 1 week</span><br><span class="line">- (instancetype)init &#123;</span><br><span class="line">    if (self = [super init]) &#123;</span><br><span class="line">        _shouldDecompressImages = YES;</span><br><span class="line">        _shouldDisableiCloud = YES;</span><br><span class="line">        _shouldCacheImagesInMemory = YES;</span><br><span class="line">        _shouldUseWeakMemoryCache = YES;</span><br><span class="line">        _diskCacheReadingOptions = 0;</span><br><span class="line">        _diskCacheWritingOptions = NSDataWritingAtomic;</span><br><span class="line">        //默认一周的缓存时间</span><br><span class="line">        _maxCacheAge = kDefaultCacheMaxCacheAge;</span><br><span class="line">        _maxCacheSize = 0;</span><br><span class="line">        _diskCacheExpireType = SDImageCacheConfigExpireTypeModificationDate;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="SDImageCache"><a href="#SDImageCache" class="headerlink" title="SDImageCache"></a>SDImageCache</h3><p>SDImageCache使用SDMemoryCache(继承NSCache)来实现内存缓存，使用NSFileManager来进行图片的硬盘存取。</p>
<h4 id="SDMemoryCache-h"><a href="#SDMemoryCache-h" class="headerlink" title="SDMemoryCache.h"></a>SDMemoryCache.h</h4><p>下面我们先来阅读下SDMemoryCache.h文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//用来表示图片的缓存类型</span><br><span class="line">typedef NS_ENUM(NSInteger, SDImageCacheType) &#123;</span><br><span class="line">    //图片来自服务器</span><br><span class="line">    SDImageCacheTypeNone,</span><br><span class="line">    //图片来自硬盘缓存</span><br><span class="line">    SDImageCacheTypeDisk,</span><br><span class="line">    //图片来自内存缓存</span><br><span class="line">    SDImageCacheTypeMemory</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//缓存图片的方式</span><br><span class="line">typedef NS_OPTIONS(NSUInteger, SDImageCacheOptions) &#123;</span><br><span class="line">    //当内存有图片，仍然查询硬盘缓存</span><br><span class="line">    SDImageCacheQueryDataWhenInMemory = 1 &lt;&lt; 0,</span><br><span class="line">    //同步的方式来获取硬盘缓存(默认异步)</span><br><span class="line">    SDImageCacheQueryDiskSync = 1 &lt;&lt; 1,</span><br><span class="line">    //缩小大图(&gt;60M)</span><br><span class="line">    SDImageCacheScaleDownLargeImages = 1 &lt;&lt; 2</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">@interface SDImageCache : NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic, nonnull, readonly) SDImageCacheConfig *config;</span><br><span class="line"></span><br><span class="line">//内存缓存的最大值(图片像素)</span><br><span class="line">@property (assign, nonatomic) NSUInteger maxMemoryCost;</span><br><span class="line"></span><br><span class="line">//内存缓存的最大数量(图片数量)</span><br><span class="line">@property (assign, nonatomic) NSUInteger maxMemoryCountLimit;</span><br><span class="line"></span><br><span class="line">//暴露的单例对象</span><br><span class="line">+ (nonnull instancetype)sharedImageCache;</span><br><span class="line"></span><br><span class="line">//指定命名空间，图片存到对应的沙盒目录中</span><br><span class="line">- (nonnull instancetype)initWithNamespace:(nonnull NSString *)ns;</span><br><span class="line"></span><br><span class="line">//指定命名空间和沙盒目录</span><br><span class="line">- (nonnull instancetype)initWithNamespace:(nonnull NSString *)ns</span><br><span class="line">                       diskCacheDirectory:(nonnull NSString *)directory;</span><br><span class="line"></span><br><span class="line">#pragma mark - Cache paths</span><br><span class="line">//获取磁盘缓存路径</span><br><span class="line">- (nullable NSString *)makeDiskCachePath:(nonnull NSString*)fullNamespace;</span><br><span class="line"></span><br><span class="line">//添加只读路径</span><br><span class="line">- (void)addReadOnlyCachePath:(nonnull NSString *)path;</span><br><span class="line"></span><br><span class="line">#pragma mark - Store Ops</span><br><span class="line"></span><br><span class="line">//异步的方式存储图片到内存和硬盘</span><br><span class="line">- (void)storeImage:(nullable UIImage *)image</span><br><span class="line">            forKey:(nullable NSString *)key</span><br><span class="line">        completion:(nullable SDWebImageNoParamsBlock)completionBlock;</span><br><span class="line"></span><br><span class="line">//异步的方式存储图片到内存和硬盘(可选，toDisk为YES才会存入硬盘)</span><br><span class="line">- (void)storeImage:(nullable UIImage *)image</span><br><span class="line">            forKey:(nullable NSString *)key</span><br><span class="line">            toDisk:(BOOL)toDisk</span><br><span class="line">        completion:(nullable SDWebImageNoParamsBlock)completionBlock;</span><br><span class="line"></span><br><span class="line">//当我们把图片存入硬盘时，需要把图片压缩为二进制格式才能存。当我们下载完图片后，得到的是图片的二进制数据，这个方法提供了imageData的入口，来避免对图片额外的压缩消耗</span><br><span class="line">- (void)storeImage:(nullable UIImage *)image</span><br><span class="line">         imageData:(nullable NSData *)imageData</span><br><span class="line">            forKey:(nullable NSString *)key</span><br><span class="line">            toDisk:(BOOL)toDisk</span><br><span class="line">        completion:(nullable SDWebImageNoParamsBlock)completionBlock;</span><br><span class="line"></span><br><span class="line">//同步的方式把图片的二进制数据存入硬盘</span><br><span class="line">- (void)storeImageDataToDisk:(nullable NSData *)imageData forKey:(nullable NSString *)key;</span><br><span class="line"></span><br><span class="line">#pragma mark - Query and Retrieve Ops</span><br><span class="line"></span><br><span class="line">//异步的方式查询硬盘中是否有key对应的缓存图片</span><br><span class="line">- (void)diskImageExistsWithKey:(nullable NSString *)key completion:(nullable SDWebImageCheckCacheCompletionBlock)completionBlock;</span><br><span class="line"></span><br><span class="line">//同步的方式查询硬盘中是否有key对应的缓存图片</span><br><span class="line">- (BOOL)diskImageDataExistsWithKey:(nullable NSString *)key;</span><br><span class="line"></span><br><span class="line">//同步的方式获取硬盘缓存的图片二进制数据</span><br><span class="line">- (nullable NSData *)diskImageDataForKey:(nullable NSString *)key;</span><br><span class="line"></span><br><span class="line">//异步的方式来获取硬盘缓存的图片</span><br><span class="line">- (nullable NSOperation *)queryCacheOperationForKey:(nullable NSString *)key done:(nullable SDCacheQueryCompletedBlock)doneBlock;</span><br><span class="line"></span><br><span class="line">//异步的方式来获取硬盘缓存的图片</span><br><span class="line">- (nullable NSOperation *)queryCacheOperationForKey:(nullable NSString *)key options:(SDImageCacheOptions)options done:(nullable SDCacheQueryCompletedBlock)doneBlock;</span><br><span class="line"></span><br><span class="line">//同步的方式来获取内存缓存的图片</span><br><span class="line">- (nullable UIImage *)imageFromMemoryCacheForKey:(nullable NSString *)key;</span><br><span class="line"></span><br><span class="line">/同步的方式获取硬盘缓存的图片</span><br><span class="line">- (nullable UIImage *)imageFromDiskCacheForKey:(nullable NSString *)key;</span><br><span class="line"></span><br><span class="line">//同步的方式，先查询内存中有没有缓存的图片，如果没有再查询硬盘中有没有缓存的图片</span><br><span class="line">- (nullable UIImage *)imageFromCacheForKey:(nullable NSString *)key;</span><br><span class="line"></span><br><span class="line">#pragma mark - Remove Ops</span><br><span class="line"></span><br><span class="line">//异步的方式移除缓存中的图片，包括内存和硬盘</span><br><span class="line">- (void)removeImageForKey:(nullable NSString *)key withCompletion:(nullable SDWebImageNoParamsBlock)completion;</span><br><span class="line"></span><br><span class="line">//异步的方式移除缓存中的图片，包括内存和硬盘(可选，fromDisk为YES移除硬盘缓存)</span><br><span class="line">- (void)removeImageForKey:(nullable NSString *)key fromDisk:(BOOL)fromDisk withCompletion:(nullable SDWebImageNoParamsBlock)completion;</span><br><span class="line"></span><br><span class="line">#pragma mark - Cache clean Ops</span><br><span class="line"></span><br><span class="line">//清除内存缓存</span><br><span class="line">- (void)clearMemory;</span><br><span class="line"></span><br><span class="line">//异步方式清除硬盘缓存</span><br><span class="line">- (void)clearDiskOnCompletion:(nullable SDWebImageNoParamsBlock)completion;</span><br><span class="line"></span><br><span class="line">//异步方式清除过期的图片</span><br><span class="line">- (void)deleteOldFilesWithCompletionBlock:(nullable SDWebImageNoParamsBlock)completionBlock;</span><br><span class="line"></span><br><span class="line">#pragma mark - Cache Info</span><br><span class="line"></span><br><span class="line">//同步方式计算缓存目录的大小</span><br><span class="line">- (NSUInteger)getSize;</span><br><span class="line"></span><br><span class="line">//同步方式计算缓存的图片数量</span><br><span class="line">- (NSUInteger)getDiskCount;</span><br><span class="line"></span><br><span class="line">//异步的方式获取缓存图片数量和大小</span><br><span class="line">- (void)calculateSizeWithCompletionBlock:(nullable SDWebImageCalculateSizeBlock)completionBlock;</span><br><span class="line"></span><br><span class="line">#pragma mark - Cache Paths</span><br><span class="line"></span><br><span class="line">//指定key，获取图片的缓存路径</span><br><span class="line">- (nullable NSString *)cachePathForKey:(nullable NSString *)key inPath:(nonnull NSString *)path;</span><br><span class="line"></span><br><span class="line">//指定key，获取图片默认的缓存路径</span><br><span class="line">- (nullable NSString *)defaultCachePathForKey:(nullable NSString *)key;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<h4 id="SDImageCache-m"><a href="#SDImageCache-m" class="headerlink" title="SDImageCache.m"></a>SDImageCache.m</h4><p>SDMemoryCache继承自NSCache。NSCache可以设置totalCostLimit，来限制缓存的总成本消耗，所以我们再添加缓存的时候需要</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)setObject:(ObjectType)obj forKey:(KeyType)key cost:(NSUInteger)g;</span><br></pre></td></tr></table></figure>
<p>通过cost来指定缓存对象消耗的成本。</p>
<h6 id="SDImageCache如何计算图片消耗的成本？"><a href="#SDImageCache如何计算图片消耗的成本？" class="headerlink" title="SDImageCache如何计算图片消耗的成本？"></a>SDImageCache如何计算图片消耗的成本？</h6><p>SDImageCache把图片的像素点来计算图片的消耗成本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FOUNDATION_STATIC_INLINE NSUInteger SDCacheCostForImage(UIImage *image) &#123;</span><br><span class="line">#if SD_MAC</span><br><span class="line">    return image.size.height * image.size.width;</span><br><span class="line">#elif SD_UIKIT || SD_WATCH</span><br><span class="line">    return image.size.height * image.size.width * image.scale * image.scale;</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="SDMemoryCache"><a href="#SDMemoryCache" class="headerlink" title="SDMemoryCache"></a>SDMemoryCache</h5><p>解析以注释的形式在代码中体现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">@interface SDMemoryCache &lt;KeyType, ObjectType&gt; ()</span><br><span class="line"></span><br><span class="line">@property (nonatomic, strong, nonnull) SDImageCacheConfig *config;</span><br><span class="line">//弱引用表</span><br><span class="line">@property (nonatomic, strong, nonnull) NSMapTable&lt;KeyType, ObjectType&gt; *weakCache; </span><br><span class="line">//多线程锁保证多线程环境下weakCache数据安全</span><br><span class="line">@property (nonatomic, strong, nonnull) dispatch_semaphore_t weakCacheLock; </span><br><span class="line"></span><br><span class="line">- (instancetype)init NS_UNAVAILABLE;</span><br><span class="line">- (instancetype)initWithConfig:(nonnull SDImageCacheConfig *)config;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation SDMemoryCache</span><br><span class="line"></span><br><span class="line">- (void)dealloc &#123;</span><br><span class="line">    [[NSNotificationCenter defaultCenter] removeObserver:self name:UIApplicationDidReceiveMemoryWarningNotification object:nil];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithConfig:(SDImageCacheConfig *)config &#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">    	//初始化弱引用表，当收到内存警告，内存缓存虽然被清理，但是有些图片已经被其他对象强引用着，这时weakCache维持这些图片的弱引用。如果需要获取这些图片就不用去硬盘获取了</span><br><span class="line">    	//NSPointerFunctionsWeakMemory，对值进行弱引用，不会对引用计数+1</span><br><span class="line">        self.weakCache = [[NSMapTable alloc] initWithKeyOptions:NSPointerFunctionsStrongMemory valueOptions:NSPointerFunctionsWeakMemory capacity:0];</span><br><span class="line">        self.weakCacheLock = dispatch_semaphore_create(1);</span><br><span class="line">        self.config = config;</span><br><span class="line">        //监听内存警告通知</span><br><span class="line">        [[NSNotificationCenter defaultCenter] addObserver:self</span><br><span class="line">                                                 selector:@selector(didReceiveMemoryWarning:)</span><br><span class="line">                                                     name:UIApplicationDidReceiveMemoryWarningNotification</span><br><span class="line">                                                   object:nil];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)didReceiveMemoryWarning:(NSNotification *)notification &#123;</span><br><span class="line">    //当收到内存警告通知，移除内存中缓存的图片</span><br><span class="line">    //同时保留weakCache，维持对被强引用着的图片的访问</span><br><span class="line">    [super removeAllObjects];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setObject:(id)obj forKey:(id)key cost:(NSUInteger)g &#123;</span><br><span class="line">    [super setObject:obj forKey:key cost:g];</span><br><span class="line">    if (!self.config.shouldUseWeakMemoryCache) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (key &amp;&amp; obj) &#123;</span><br><span class="line">        // 存入弱引用表</span><br><span class="line">        LOCK(self.weakCacheLock);</span><br><span class="line">        [self.weakCache setObject:obj forKey:key];</span><br><span class="line">        UNLOCK(self.weakCacheLock);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (id)objectForKey:(id)key &#123;</span><br><span class="line">    id obj = [super objectForKey:key];</span><br><span class="line">    if (!self.config.shouldUseWeakMemoryCache) &#123;</span><br><span class="line">        return obj;</span><br><span class="line">    &#125;</span><br><span class="line">    if (key &amp;&amp; !obj) &#123;</span><br><span class="line">        LOCK(self.weakCacheLock);</span><br><span class="line">        obj = [self.weakCache objectForKey:key];</span><br><span class="line">        UNLOCK(self.weakCacheLock);</span><br><span class="line">        if (obj) &#123;</span><br><span class="line">            // 把通过弱引用表获取的图片添加到内存缓存中</span><br><span class="line">            NSUInteger cost = 0;</span><br><span class="line">            if ([obj isKindOfClass:[UIImage class]]) &#123;</span><br><span class="line">                cost = SDCacheCostForImage(obj);</span><br><span class="line">            &#125;</span><br><span class="line">            [super setObject:obj forKey:key cost:cost];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)removeObjectForKey:(id)key &#123;</span><br><span class="line">    [super removeObjectForKey:key];</span><br><span class="line">    if (!self.config.shouldUseWeakMemoryCache) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (key) &#123;</span><br><span class="line">        // 从weakCache移除</span><br><span class="line">        LOCK(self.weakCacheLock);</span><br><span class="line">        [self.weakCache removeObjectForKey:key];</span><br><span class="line">        UNLOCK(self.weakCacheLock);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)removeAllObjects &#123;</span><br><span class="line">    [super removeAllObjects];</span><br><span class="line">    if (!self.config.shouldUseWeakMemoryCache) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // 清除弱引用表</span><br><span class="line">    LOCK(self.weakCacheLock);</span><br><span class="line">    [self.weakCache removeAllObjects];</span><br><span class="line">    UNLOCK(self.weakCacheLock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#else</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithConfig:(SDImageCacheConfig *)config &#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>SDImageCache私有拓展的属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//内存缓存管理实例</span><br><span class="line">@property (strong, nonatomic, nonnull) SDMemoryCache *memCache;</span><br><span class="line">//硬盘缓存路径</span><br><span class="line">@property (strong, nonatomic, nonnull) NSString *diskCachePath;</span><br><span class="line">//读取缓存图片额外的路径，以通过addReadOnlyCachePath:这个方法往里边添加路径</span><br><span class="line">@property (strong, nonatomic, nullable) NSMutableArray&lt;NSString *&gt; *customPaths;</span><br><span class="line">//访问操作硬盘缓存时用到的串行队列</span><br><span class="line">@property (strong, nonatomic, nullable) dispatch_queue_t ioQueue;</span><br><span class="line">//存储图片到硬盘的文件管理者</span><br><span class="line">@property (strong, nonatomic, nonnull) NSFileManager *fileManager;</span><br></pre></td></tr></table></figure>
<p>初始化函数最终都会调用</p>
<p>- (nonnull instancetype)initWithNamespace:(nonnull NSString *)ns</p>
<p>​                       diskCacheDirectory:(nonnull NSString *)directory</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">- (nonnull instancetype)initWithNamespace:(nonnull NSString *)ns</span><br><span class="line">                       diskCacheDirectory:(nonnull NSString *)directory &#123;</span><br><span class="line">    if ((self = [super init])) &#123;</span><br><span class="line">    	//初始化参数</span><br><span class="line">        NSString *fullNamespace = [@&quot;com.hackemist.SDWebImageCache.&quot; stringByAppendingString:ns];</span><br><span class="line">        _ioQueue = dispatch_queue_create(&quot;com.hackemist.SDWebImageCache&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">        _config = [[SDImageCacheConfig alloc] init];</span><br><span class="line">        _memCache = [[SDMemoryCache alloc] initWithConfig:_config];</span><br><span class="line">        _memCache.name = fullNamespace;</span><br><span class="line">        if (directory != nil) &#123;</span><br><span class="line">            _diskCachePath = [directory stringByAppendingPathComponent:fullNamespace];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            NSString *path = [self makeDiskCachePath:ns];</span><br><span class="line">            _diskCachePath = path;</span><br><span class="line">        &#125;</span><br><span class="line">        dispatch_sync(_ioQueue, ^&#123;</span><br><span class="line">            self.fileManager = [NSFileManager new];</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">#if SD_UIKIT</span><br><span class="line">		//监听通知来清除过期的图片缓存数据</span><br><span class="line">        [[NSNotificationCenter defaultCenter] addObserver:self</span><br><span class="line">                                                 selector:@selector(deleteOldFiles)</span><br><span class="line">                                                     name:UIApplicationWillTerminateNotification</span><br><span class="line">                                                   object:nil];</span><br><span class="line">        [[NSNotificationCenter defaultCenter] addObserver:self</span><br><span class="line">                                                 selector:@selector(backgroundDeleteOldFiles)</span><br><span class="line">                                                     name:UIApplicationDidEnterBackgroundNotification</span><br><span class="line">                                                   object:nil];</span><br><span class="line">#endif</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>如果进入沙盒查看缓存的图片，可以发现文件名是用过md5的格式来命名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (nullable NSString *)cachedFileNameForKey:(nullable NSString *)key &#123;</span><br><span class="line">    const char *str = key.UTF8String;</span><br><span class="line">    if (str == NULL) &#123;</span><br><span class="line">        str = &quot;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    unsigned char r[CC_MD5_DIGEST_LENGTH];</span><br><span class="line">    //计算key的md5值</span><br><span class="line">    CC_MD5(str, (CC_LONG)strlen(str), r);</span><br><span class="line">    NSURL *keyURL = [NSURL URLWithString:key];</span><br><span class="line">    NSString *ext = keyURL ? keyURL.pathExtension : key.pathExtension;</span><br><span class="line">    //md5值拼接文件后缀</span><br><span class="line">    NSString *filename = [NSString stringWithFormat:@&quot;%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%@&quot;,</span><br><span class="line">                          r[0], r[1], r[2], r[3], r[4], r[5], r[6], r[7], r[8], r[9], r[10],</span><br><span class="line">                          r[11], r[12], r[13], r[14], r[15], ext.length == 0 ? @&quot;&quot; : [NSString stringWithFormat:@&quot;.%@&quot;, ext]];</span><br><span class="line">    return filename;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>异步缓存图片</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">- (void)storeImage:(nullable UIImage *)image</span><br><span class="line">         imageData:(nullable NSData *)imageData</span><br><span class="line">            forKey:(nullable NSString *)key</span><br><span class="line">            toDisk:(BOOL)toDisk</span><br><span class="line">        completion:(nullable SDWebImageNoParamsBlock)completionBlock &#123;</span><br><span class="line">    if (!image || !key) &#123;</span><br><span class="line">        if (completionBlock) &#123;</span><br><span class="line">            completionBlock();</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果允许内存缓存，先把图片缓存到内存</span><br><span class="line">    if (self.config.shouldCacheImagesInMemory) &#123;</span><br><span class="line">        NSUInteger cost = SDCacheCostForImage(image);</span><br><span class="line">        [self.memCache setObject:image forKey:key cost:cost];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (toDisk) &#123;</span><br><span class="line">        dispatch_async(self.ioQueue, ^&#123;</span><br><span class="line">        	//一般图片的大小都不会很小，对图片进行编码过程中也会产出一些开销不小的临时对象,在子线程中添加自动释放池，可以提前释放这些对象，缓解内存压力。</span><br><span class="line">            @autoreleasepool &#123;</span><br><span class="line">                NSData *data = imageData;</span><br><span class="line">                if (!data &amp;&amp; image) &#123;</span><br><span class="line">                    SDImageFormat format;</span><br><span class="line">                    if (SDCGImageRefContainsAlpha(image.CGImage)) &#123;</span><br><span class="line">                        format = SDImageFormatPNG;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        format = SDImageFormatJPEG;</span><br><span class="line">                    &#125;</span><br><span class="line">                    //把图片进行编码，得到可以存储的二进制数据</span><br><span class="line">                    data = [[SDWebImageCodersManager sharedInstance] encodedDataWithImage:image format:format];</span><br><span class="line">                &#125;</span><br><span class="line">                [self _storeImageDataToDisk:data forKey:key];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            if (completionBlock) &#123;</span><br><span class="line">                dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                    completionBlock();</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (completionBlock) &#123;</span><br><span class="line">            completionBlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>内部方法：使用的把图片二进制数据存入硬盘</p>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (void)_storeImageDataToDisk:(nullable NSData *)imageData forKey:(nullable NSString *)key &#123;</span><br><span class="line">    if (!imageData || !key) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (![self.fileManager fileExistsAtPath:_diskCachePath]) &#123;</span><br><span class="line">    	//如果还没有缓存目录，通过fileManager生成缓存目录</span><br><span class="line">        [self.fileManager createDirectoryAtPath:_diskCachePath withIntermediateDirectories:YES attributes:nil error:NULL];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 获取缓存的文件名,对key进行md5加密</span><br><span class="line">    NSString *cachePathForKey = [self defaultCachePathForKey:key];</span><br><span class="line">    NSURL *fileURL = [NSURL fileURLWithPath:cachePathForKey];</span><br><span class="line">    //保存到硬盘</span><br><span class="line">    [imageData writeToURL:fileURL options:self.config.diskCacheWritingOptions error:nil];</span><br><span class="line">    </span><br><span class="line">    // 禁止iCloud备份</span><br><span class="line">    if (self.config.shouldDisableiCloud) &#123;</span><br><span class="line">        [fileURL setResourceValue:@YES forKey:NSURLIsExcludedFromBackupKey error:nil];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>因为从硬盘查询是否有缓存图片会是一个比较耗时的操作，所以SDImageCache还提供了异步的方式，通过block回调查询结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (void)diskImageExistsWithKey:(nullable NSString *)key completion:(nullable SDWebImageCheckCacheCompletionBlock)completionBlock &#123;</span><br><span class="line">    dispatch_async(self.ioQueue, ^&#123;</span><br><span class="line">        BOOL exists = [self _diskImageDataExistsWithKey:key];</span><br><span class="line">        if (completionBlock) &#123;</span><br><span class="line">            dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                completionBlock(exists);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>在命名空间指定的目录和自定义只读路径中查询获取图片</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">- (nullable NSData *)diskImageDataBySearchingAllPathsForKey:(nullable NSString *)key &#123;</span><br><span class="line">    NSString *defaultPath = [self defaultCachePathForKey:key];</span><br><span class="line">    //在缓存目录查找获取图片</span><br><span class="line">    NSData *data = [NSData dataWithContentsOfFile:defaultPath options:self.config.diskCacheReadingOptions error:nil];</span><br><span class="line">    if (data) &#123;</span><br><span class="line">        return data;</span><br><span class="line">    &#125;</span><br><span class="line">    data = [NSData dataWithContentsOfFile:defaultPath.stringByDeletingPathExtension options:self.config.diskCacheReadingOptions error:nil];</span><br><span class="line">    if (data) &#123;</span><br><span class="line">        return data;</span><br><span class="line">    &#125;</span><br><span class="line">	//在自定义的只读路径中查询获取图片</span><br><span class="line">    NSArray&lt;NSString *&gt; *customPaths = [self.customPaths copy];</span><br><span class="line">    for (NSString *path in customPaths) &#123;</span><br><span class="line">        NSString *filePath = [self cachePathForKey:key inPath:path];</span><br><span class="line">        NSData *imageData = [NSData dataWithContentsOfFile:filePath options:self.config.diskCacheReadingOptions error:nil];</span><br><span class="line">        if (imageData) &#123;</span><br><span class="line">            return imageData;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        imageData = [NSData dataWithContentsOfFile:filePath.stringByDeletingPathExtension options:self.config.diskCacheReadingOptions error:nil];</span><br><span class="line">        if (imageData) &#123;</span><br><span class="line">            return imageData;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>从硬盘中获取图片(同步的方式获取)，查询到图片后shouldCacheImagesInMemory=YES同步保存到内存缓存中，下次再获取的时候直接从内存中获取</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">- (nullable UIImage *)imageFromDiskCacheForKey:(nullable NSString *)key &#123;</span><br><span class="line">    UIImage *diskImage = [self diskImageForKey:key];</span><br><span class="line">    if (diskImage &amp;&amp; self.config.shouldCacheImagesInMemory) &#123;</span><br><span class="line">        NSUInteger cost = SDCacheCostForImage(diskImage);</span><br><span class="line">        //同步缓存到内存</span><br><span class="line">        [self.memCache setObject:diskImage forKey:key cost:cost];</span><br><span class="line">    &#125;</span><br><span class="line">    return diskImage;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (nullable UIImage *)imageFromCacheForKey:(nullable NSString *)key &#123;</span><br><span class="line">	//先从内存中尝试获取缓存图片</span><br><span class="line">    UIImage *image = [self imageFromMemoryCacheForKey:key];</span><br><span class="line">    if (image) &#123;</span><br><span class="line">        return image;</span><br><span class="line">    &#125;</span><br><span class="line">    //内存中没有缓存，尝试从硬盘中获取 imageFromDiskCacheForKey 就是上面的方法</span><br><span class="line">    image = [self imageFromDiskCacheForKey:key];</span><br><span class="line">    return image;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (nullable UIImage *)diskImageForKey:(nullable NSString *)key &#123;</span><br><span class="line">    NSData *data = [self diskImageDataForKey:key];</span><br><span class="line">    return [self diskImageForKey:key data:data];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (nullable UIImage *)diskImageForKey:(nullable NSString *)key data:(nullable NSData *)data &#123;</span><br><span class="line">    return [self diskImageForKey:key data:data options:0];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (nullable UIImage *)diskImageForKey:(nullable NSString *)key data:(nullable NSData *)data options:(SDImageCacheOptions)options &#123;</span><br><span class="line">    if (data) &#123;</span><br><span class="line">    	//实例化一个uiimage，此时的uiimage还没有进行解码</span><br><span class="line">        UIImage *image = [[SDWebImageCodersManager sharedInstance] decodedImageWithData:data];</span><br><span class="line">        image = [self scaledImageForKey:key image:image];</span><br><span class="line">        if (self.config.shouldDecompressImages) &#123;</span><br><span class="line">        	//对image进行预解码</span><br><span class="line">            BOOL shouldScaleDown = options &amp; SDImageCacheScaleDownLargeImages;</span><br><span class="line">            image = [[SDWebImageCodersManager sharedInstance] decompressedImageWithImage:image data:&amp;data options:@&#123;SDWebImageCoderScaleDownLargeImagesKey: @(shouldScaleDown)&#125;];</span><br><span class="line">        &#125;</span><br><span class="line">        return image;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>异步的方式获取硬盘缓存图片</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">- (nullable NSOperation *)queryCacheOperationForKey:(nullable NSString *)key options:(SDImageCacheOptions)options done:(nullable SDCacheQueryCompletedBlock)doneBlock &#123;</span><br><span class="line">    if (!key) &#123;</span><br><span class="line">        if (doneBlock) &#123;</span><br><span class="line">            doneBlock(nil, nil, SDImageCacheTypeNone);</span><br><span class="line">        &#125;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 首先检查内存中是否有缓存的图片</span><br><span class="line">    UIImage *image = [self imageFromMemoryCacheForKey:key];</span><br><span class="line">    //当内存中有缓存，并且SDImageCacheQueryDataWhenInMemory(内存中有缓存仍然查询硬盘缓存)为false，立即返回内存缓存的图片</span><br><span class="line">    BOOL shouldQueryMemoryOnly = (image &amp;&amp; !(options &amp; SDImageCacheQueryDataWhenInMemory));</span><br><span class="line">    if (shouldQueryMemoryOnly) &#123;</span><br><span class="line">        if (doneBlock) &#123;</span><br><span class="line">            doneBlock(image, nil, SDImageCacheTypeMemory);</span><br><span class="line">        &#125;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    NSOperation *operation = [NSOperation new];</span><br><span class="line">    void(^queryDiskBlock)(void) =  ^&#123;</span><br><span class="line">        if (operation.isCancelled) &#123;</span><br><span class="line">            // operation取消，直接返回</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        @autoreleasepool &#123;</span><br><span class="line">        	//从硬盘获取缓存</span><br><span class="line">            NSData *diskData = [self diskImageDataBySearchingAllPathsForKey:key];</span><br><span class="line">            UIImage *diskImage;</span><br><span class="line">            SDImageCacheType cacheType = SDImageCacheTypeDisk;</span><br><span class="line">            if (image) &#123;</span><br><span class="line">                // 如果内存本来就有缓存图片，则把内存缓存的图片返回，可以省去对图片再一次解码</span><br><span class="line">                diskImage = image;</span><br><span class="line">                cacheType = SDImageCacheTypeMemory;</span><br><span class="line">            &#125; else if (diskData) &#123;</span><br><span class="line">                // 如果内存没有缓存的图片，那么从硬盘得到的是图片压缩的二进制数据，使用前需要先解码</span><br><span class="line">                diskImage = [self diskImageForKey:key data:diskData options:options];</span><br><span class="line">                if (diskImage &amp;&amp; self.config.shouldCacheImagesInMemory) &#123;</span><br><span class="line">                	//同步保存到内存缓存中</span><br><span class="line">                    NSUInteger cost = SDCacheCostForImage(diskImage);</span><br><span class="line">                    [self.memCache setObject:diskImage forKey:key cost:cost];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            if (doneBlock) &#123;</span><br><span class="line">                if (options &amp; SDImageCacheQueryDiskSync) &#123;</span><br><span class="line">                    doneBlock(diskImage, diskData, cacheType);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                        doneBlock(diskImage, diskData, cacheType);</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    if (options &amp; SDImageCacheQueryDiskSync) &#123;</span><br><span class="line">        queryDiskBlock();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        dispatch_async(self.ioQueue, queryDiskBlock);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return operation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>从缓存中移除图片</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">- (void)removeImageForKey:(nullable NSString *)key fromDisk:(BOOL)fromDisk withCompletion:(nullable SDWebImageNoParamsBlock)completion &#123;</span><br><span class="line">    if (key == nil) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (self.config.shouldCacheImagesInMemory) &#123;</span><br><span class="line">        [self.memCache removeObjectForKey:key];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (fromDisk) &#123;</span><br><span class="line">        dispatch_async(self.ioQueue, ^&#123;</span><br><span class="line">            [self.fileManager removeItemAtPath:[self defaultCachePathForKey:key] error:nil];</span><br><span class="line">            </span><br><span class="line">            if (completion) &#123;</span><br><span class="line">                dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                    completion();</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; else if (completion)&#123;</span><br><span class="line">        completion();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>清空缓存</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//清空内存缓存</span><br><span class="line">- (void)clearMemory &#123;</span><br><span class="line">    [self.memCache removeAllObjects];</span><br><span class="line">&#125;</span><br><span class="line">//清空硬盘缓存</span><br><span class="line">- (void)clearDiskOnCompletion:(nullable SDWebImageNoParamsBlock)completion &#123;</span><br><span class="line">    dispatch_async(self.ioQueue, ^&#123;</span><br><span class="line">        [self.fileManager removeItemAtPath:self.diskCachePath error:nil];</span><br><span class="line">        [self.fileManager createDirectoryAtPath:self.diskCachePath</span><br><span class="line">                withIntermediateDirectories:YES</span><br><span class="line">                                 attributes:nil</span><br><span class="line">                                      error:NULL];</span><br><span class="line"></span><br><span class="line">        if (completion) &#123;</span><br><span class="line">            dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                completion();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>SDImageCache在app退出，或者进入到后台，都会对缓存目录下的图片进行清理，把过期的图片移除掉</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">- (void)deleteOldFilesWithCompletionBlock:(nullable SDWebImageNoParamsBlock)completionBlock &#123;</span><br><span class="line">    dispatch_async(self.ioQueue, ^&#123;</span><br><span class="line">        NSURL *diskCacheURL = [NSURL fileURLWithPath:self.diskCachePath isDirectory:YES];</span><br><span class="line"></span><br><span class="line">        NSURLResourceKey cacheContentDateKey = NSURLContentModificationDateKey;</span><br><span class="line">        switch (self.config.diskCacheExpireType) &#123;</span><br><span class="line">            case SDImageCacheConfigExpireTypeAccessDate:</span><br><span class="line">            	//最近访问的时间到现在作为过期时间</span><br><span class="line">                cacheContentDateKey = NSURLContentAccessDateKey;</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            case SDImageCacheConfigExpireTypeModificationDate:</span><br><span class="line">            	//最近修改的时间到现在作为过期时间</span><br><span class="line">                cacheContentDateKey = NSURLContentModificationDateKey;</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            default:</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        NSArray&lt;NSString *&gt; *resourceKeys = @[NSURLIsDirectoryKey, cacheContentDateKey, NSURLTotalFileAllocatedSizeKey];</span><br><span class="line"></span><br><span class="line">        // This enumerator prefetches useful properties for our cache files.</span><br><span class="line">        NSDirectoryEnumerator *fileEnumerator = [self.fileManager enumeratorAtURL:diskCacheURL</span><br><span class="line">                                                   includingPropertiesForKeys:resourceKeys</span><br><span class="line">                                                                      options:NSDirectoryEnumerationSkipsHiddenFiles</span><br><span class="line">                                                                 errorHandler:NULL];</span><br><span class="line">		//通过SDImageCacheConfig.maxCacheAge计算出该被移除的缓存时间边界值</span><br><span class="line">        NSDate *expirationDate = [NSDate dateWithTimeIntervalSinceNow:-self.config.maxCacheAge];</span><br><span class="line">        //用来保存未过期的缓存图片</span><br><span class="line">        NSMutableDictionary&lt;NSURL *, NSDictionary&lt;NSString *, id&gt; *&gt; *cacheFiles = [NSMutableDictionary dictionary];</span><br><span class="line">        //用来记录当前缓存大小</span><br><span class="line">        NSUInteger currentCacheSize = 0;</span><br><span class="line">        //用来保存过期图片的url</span><br><span class="line">        NSMutableArray&lt;NSURL *&gt; *urlsToDelete = [[NSMutableArray alloc] init];</span><br><span class="line">        </span><br><span class="line">        // 在缓存目录下遍历图片，把过期的缓存图片移除掉，把未过期的图片添加到cacheFiles来进行下一步的清理工作(以size作为清理标准)</span><br><span class="line">        for (NSURL *fileURL in fileEnumerator) &#123;</span><br><span class="line">            NSError *error;</span><br><span class="line">            NSDictionary&lt;NSString *, id&gt; *resourceValues = [fileURL resourceValuesForKeys:resourceKeys error:&amp;error];</span><br><span class="line"></span><br><span class="line">            // 跳过文件夹</span><br><span class="line">            if (error || !resourceValues || [resourceValues[NSURLIsDirectoryKey] boolValue]) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 移除过期的图片</span><br><span class="line">            NSDate *modifiedDate = resourceValues[cacheContentDateKey];</span><br><span class="line">            //laterDate:返回的是较晚的时间，如果修改时间比上面计算的缓存时间边界值还早，就说明该缓存图片已经过期了，添加到urlsToDelete等待删除</span><br><span class="line">            if ([[modifiedDate laterDate:expirationDate] isEqualToDate:expirationDate]) &#123;</span><br><span class="line">                [urlsToDelete addObject:fileURL];</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            NSNumber *totalAllocatedSize = resourceValues[NSURLTotalFileAllocatedSizeKey];</span><br><span class="line">            currentCacheSize += totalAllocatedSize.unsignedIntegerValue;</span><br><span class="line">            cacheFiles[fileURL] = resourceValues;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //循环遍历，移除过期的图片</span><br><span class="line">        for (NSURL *fileURL in urlsToDelete) &#123;</span><br><span class="line">            [self.fileManager removeItemAtURL:fileURL error:nil];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 如果我们设置了SDImageCacheConfig.maxCacheSize，并且当前缓存目录的大小大于config.maxCacheSize，需要对缓存目录进行二次清理，直到缓存目录大小 &lt;= config.maxCacheSize/2</span><br><span class="line">        if (self.config.maxCacheSize &gt; 0 &amp;&amp; currentCacheSize &gt; self.config.maxCacheSize) &#123;</span><br><span class="line">            const NSUInteger desiredCacheSize = self.config.maxCacheSize / 2;</span><br><span class="line">            //把缓存的图片从新排序，较早的图片放在前面</span><br><span class="line">            NSArray&lt;NSURL *&gt; *sortedFiles = [cacheFiles keysSortedByValueWithOptions:NSSortConcurrent</span><br><span class="line">                                                                     usingComparator:^NSComparisonResult(id obj1, id obj2) &#123;</span><br><span class="line">                                                                         return [obj1[NSURLContentModificationDateKey] compare:obj2[NSURLContentModificationDateKey]];</span><br><span class="line">                                                                     &#125;];</span><br><span class="line"></span><br><span class="line">            // 删除图片知道缓存目录大小 &lt;= config.maxCacheSize/2</span><br><span class="line">            for (NSURL *fileURL in sortedFiles) &#123;</span><br><span class="line">                if ([self.fileManager removeItemAtURL:fileURL error:nil]) &#123;</span><br><span class="line">                    NSDictionary&lt;NSString *, id&gt; *resourceValues = cacheFiles[fileURL];</span><br><span class="line">                    NSNumber *totalAllocatedSize = resourceValues[NSURLTotalFileAllocatedSizeKey];</span><br><span class="line">                    currentCacheSize -= totalAllocatedSize.unsignedIntegerValue;</span><br><span class="line">                    if (currentCacheSize &lt; desiredCacheSize) &#123;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (completionBlock) &#123;</span><br><span class="line">            dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                completionBlock();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>同步的方式获取缓存目录的大小和文件数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (NSUInteger)getSize &#123;</span><br><span class="line">    __block NSUInteger size = 0;</span><br><span class="line">    dispatch_sync(self.ioQueue, ^&#123;</span><br><span class="line">        NSDirectoryEnumerator *fileEnumerator = [self.fileManager enumeratorAtPath:self.diskCachePath];</span><br><span class="line">        for (NSString *fileName in fileEnumerator) &#123;</span><br><span class="line">            NSString *filePath = [self.diskCachePath stringByAppendingPathComponent:fileName];</span><br><span class="line">            NSDictionary&lt;NSString *, id&gt; *attrs = [self.fileManager attributesOfItemAtPath:filePath error:nil];</span><br><span class="line">            size += [attrs fileSize];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    return size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSUInteger)getDiskCount &#123;</span><br><span class="line">    __block NSUInteger count = 0;</span><br><span class="line">    dispatch_sync(self.ioQueue, ^&#123;</span><br><span class="line">        NSDirectoryEnumerator *fileEnumerator = [self.fileManager enumeratorAtPath:self.diskCachePath];</span><br><span class="line">        count = fileEnumerator.allObjects.count;</span><br><span class="line">    &#125;);</span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>异步的方式获取缓存目录的大小和文件数，block回调</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">- (void)calculateSizeWithCompletionBlock:(nullable SDWebImageCalculateSizeBlock)completionBlock &#123;</span><br><span class="line">    NSURL *diskCacheURL = [NSURL fileURLWithPath:self.diskCachePath isDirectory:YES];</span><br><span class="line"></span><br><span class="line">    dispatch_async(self.ioQueue, ^&#123;</span><br><span class="line">        NSUInteger fileCount = 0;</span><br><span class="line">        NSUInteger totalSize = 0;</span><br><span class="line"></span><br><span class="line">        NSDirectoryEnumerator *fileEnumerator = [self.fileManager enumeratorAtURL:diskCacheURL</span><br><span class="line">                                                   includingPropertiesForKeys:@[NSFileSize]</span><br><span class="line">                                                                      options:NSDirectoryEnumerationSkipsHiddenFiles</span><br><span class="line">                                                                 errorHandler:NULL];</span><br><span class="line"></span><br><span class="line">        for (NSURL *fileURL in fileEnumerator) &#123;</span><br><span class="line">            NSNumber *fileSize;</span><br><span class="line">            [fileURL getResourceValue:&amp;fileSize forKey:NSURLFileSizeKey error:NULL];</span><br><span class="line">            totalSize += fileSize.unsignedIntegerValue;</span><br><span class="line">            fileCount += 1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (completionBlock) &#123;</span><br><span class="line">            dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                completionBlock(fileCount, totalSize);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/06/iOS多线程之：GCD/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DevHuangjb">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="黄锦标的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/06/iOS多线程之：GCD/" itemprop="url">iOS多线程之：GCD</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-01-06T13:47:46+08:00">
                2019-01-06
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>我个人在开发中，遇到并发的操作，比较习惯用GCD来实现。原因很简单，高效！方便！</p>
<h6 id="什么是GCD"><a href="#什么是GCD" class="headerlink" title="什么是GCD?"></a>什么是GCD?</h6><blockquote>
<p>百度百科：Grand Central Dispatch (GCD)是Apple开发的一个多核编程的较新的解决方法。它主要用于优化应用程序以支持多核处理器以及其他对称多处理系统。它是一个在线程池模式的基础上执行的并行任务。</p>
</blockquote>
<p>从字面上来看，GCD意思是“伟大的中枢调度器”。是纯C语言的API,提供了非常强大的函数。</p>
<h6 id="GCD的优势"><a href="#GCD的优势" class="headerlink" title="GCD的优势"></a>GCD的优势</h6><ul>
<li>GCD是苹果为多核运算提出的解决方案，可以更好的利用CPU的多核优势</li>
<li>GCD会自动管理线程的生命周期(创建线程，调度任务，销毁线程)</li>
<li>方便的使用API，程序员只需要专注于要执行的任务</li>
</ul>
<h6 id="任务和队列"><a href="#任务和队列" class="headerlink" title="任务和队列"></a>任务和队列</h6><p>GCD开发中，两个很重要的概念就是任务和队列，核心就是把要执行的任务添加到队列里面</p>
<p>队列：用于管理任务的数据结构，队列遵循严格的FIFO原则，即先添加的任务先执行，后添加的任务后执行。</p>
<ul>
<li>串行队列：只会开辟一条子线程，队列上面的任务在这条线程上面一个一个依次的执行</li>
<li>并行队列：可以开辟多条线程，并行的执行队列上面的任务。</li>
</ul>
<p><strong>主队列：</strong>主队列是一种特殊的串行队列，所有放在主队列上面的任务都会在主线程当中执行。所以，主要用于操作UI元素的任务。使用dispatch_get_main_queue()来获取主队列</p>
<p><strong>全局队列：</strong>苹果默认创建的全局的并发队列。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">获取全局队列：dispatch_get_global_queue(long identifier, unsigned long flags );</span><br><span class="line">identifier：为队列指定的优先级</span><br><span class="line">flags：保留参数，必须传0，传其他值返回的nil。</span><br><span class="line">* iOS8后，苹果推出并推荐使用qos_class来指定全局队列的优先级</span><br><span class="line">* 以下优先级依次降低</span><br><span class="line">*  - QOS_CLASS_USER_INTERACTIVE</span><br><span class="line">*  - QOS_CLASS_USER_INITIATED</span><br><span class="line">*  - QOS_CLASS_DEFAULT</span><br><span class="line">*  - QOS_CLASS_UTILITY</span><br><span class="line">*  - QOS_CLASS_BACKGROUND</span><br><span class="line">*</span><br><span class="line">* 仍然可以使用priority来指定全局队列的优先级,priority和qos_class的映射关系如下：</span><br><span class="line">*  - DISPATCH_QUEUE_PRIORITY_HIGH:         QOS_CLASS_USER_INITIATED</span><br><span class="line">*  - DISPATCH_QUEUE_PRIORITY_DEFAULT:      QOS_CLASS_DEFAULT</span><br><span class="line">*  - DISPATCH_QUEUE_PRIORITY_LOW:          QOS_CLASS_UTILITY</span><br><span class="line">*  - DISPATCH_QUEUE_PRIORITY_BACKGROUND:   QOS_CLASS_BACKGROUND</span><br></pre></td></tr></table></figure>
<p>任务：就是我们要执行的操作。</p>
<p>任务执行的两种方式：</p>
<ul>
<li><p>同步执行：</p>
<ul>
<li>dispatch_sync同步的添加任务到队列中，队列中后面的任务必须等到同步执行的任务执行结束后才能执行；</li>
<li>不会开辟子线程，任务是在当前线程执行的</li>
</ul>
</li>
<li><p>异步执行：</p>
<ul>
<li><p>dispatch_asyn异步的添加任务到队列中，队列中后面的任务不用等到异步执行的任务结束就能执行。</p>
</li>
<li><p>具备开启子线程执行任务的能力</p>
</li>
<li><p>异步执行具备开启线程的能力，但不一定都开启子线程。在主队列不允许开新线程。</p>
</li>
</ul>
</li>
</ul>
<h6 id="GCD的使用"><a href="#GCD的使用" class="headerlink" title="GCD的使用"></a>GCD的使用</h6><p>根据两种类型的队列和两种不同的执行方式，我们可以有四种组合来使用GCD</p>
<ul>
<li>在串行队列上面同步执行任务</li>
<li><p>在串行队列上面异步执行任务</p>
</li>
<li><p>在并发队列上面同步执行任务</p>
</li>
<li>在并发队列上面异步执行任务</li>
<li>在主队列上面同步执行任务</li>
<li>在主队列上面异步执行任务</li>
</ul>
<p>以下的测试方法都是在 <strong><em>主线程</em></strong> 执行：</p>
<ol>
<li><p>在串行队列上面同步执行任务：不开辟子线程，任务顺序一个一个在当前线程执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (void)sync_serial &#123;</span><br><span class="line">    dispatch_queue_t queue = dispatch_queue_create(NULL, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">        dispatch_sync(queue, ^&#123;</span><br><span class="line">            NSLog(@&quot;%@ %d&quot;, [NSThread currentThread], i);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">控制台输出：</span><br><span class="line">2019-01-06 15:38:49.235601+0800 GCD_Demo[1665:267519] &lt;NSThread: 0x6000000a5400&gt;&#123;number = 1, name = main&#125; 0</span><br><span class="line">2019-01-06 15:38:49.235734+0800 GCD_Demo[1665:267519] &lt;NSThread: 0x6000000a5400&gt;&#123;number = 1, name = main&#125; 1</span><br><span class="line">2019-01-06 15:38:49.235838+0800 GCD_Demo[1665:267519] &lt;NSThread: 0x6000000a5400&gt;&#123;number = 1, name = main&#125; 2</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="2">
<li><p>在串行队列上面异步执行任务：只会开辟一条子线程，任务在子线程依次执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (void)async_serial &#123;</span><br><span class="line">    dispatch_queue_t queue = dispatch_queue_create(NULL, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">        dispatch_async(queue, ^&#123;</span><br><span class="line">            NSLog(@&quot;%@ %d&quot;, [NSThread currentThread], i);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">控制台输出：</span><br><span class="line">2019-01-06 15:34:52.334973+0800 GCD_Demo[1594:253049] &lt;NSThread: 0x600003ce1f40&gt;&#123;number = 3, name = (null)&#125; 0</span><br><span class="line">2019-01-06 15:34:52.335465+0800 GCD_Demo[1594:253049] &lt;NSThread: 0x600003ce1f40&gt;&#123;number = 3, name = (null)&#125; 1</span><br><span class="line">2019-01-06 15:34:52.335570+0800 GCD_Demo[1594:253049] &lt;NSThread: 0x600003ce1f40&gt;&#123;number = 3, name = (null)&#125; 2</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="3">
<li>在并发队列上面同步执行任务：不开辟子线程，任务顺序一个一个在当前线程执行</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (void)sync_concurrent &#123;</span><br><span class="line">    dispatch_queue_t queue = dispatch_queue_create(NULL, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">        dispatch_sync(queue, ^&#123;</span><br><span class="line">            NSLog(@&quot;%@ %d&quot;, [NSThread currentThread], i);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">控制台输出：</span><br><span class="line">2019-01-06 15:36:59.044932+0800 GCD_Demo[1641:260902] &lt;NSThread: 0x600001e7e940&gt;&#123;number = 1, name = main&#125; 0</span><br><span class="line">2019-01-06 15:36:59.045100+0800 GCD_Demo[1641:260902] &lt;NSThread: 0x600001e7e940&gt;&#123;number = 1, name = main&#125; 1</span><br><span class="line">2019-01-06 15:36:59.045196+0800 GCD_Demo[1641:260902] &lt;NSThread: 0x600001e7e940&gt;&#123;number = 1, name = main&#125; 2</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>在并发队列上面异步执行任务：会开辟多个线程同时执行多个任务，具体开辟的线程数由内核决定</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (void)async_concurrent &#123;</span><br><span class="line">    dispatch_queue_t queue = dispatch_queue_create(NULL, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">        dispatch_async(queue, ^&#123;</span><br><span class="line">            NSLog(@&quot;%@ %d&quot;, [NSThread currentThread], i);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">控制台输出：</span><br><span class="line">2019-01-06 15:40:08.082757+0800 GCD_Demo[1695:274396] &lt;NSThread: 0x600000dba740&gt;&#123;number = 5, name = (null)&#125; 2</span><br><span class="line">2019-01-06 15:40:08.082768+0800 GCD_Demo[1695:274397] &lt;NSThread: 0x600000db6ac0&gt;&#123;number = 4, name = (null)&#125; 1</span><br><span class="line">2019-01-06 15:40:08.082775+0800 GCD_Demo[1695:274395] &lt;NSThread: 0x600000da2980&gt;&#123;number = 3, name = (null)&#125; 0</span><br></pre></td></tr></table></figure>
<ol start="5">
<li><p>在主队列上面异步执行任务：不开辟子线程，任务顺序一个一个在主线程执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (void)async_main_queue &#123;</span><br><span class="line">    dispatch_queue_t queue = dispatch_get_main_queue();</span><br><span class="line">    for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">        dispatch_async(queue, ^&#123;</span><br><span class="line">            NSLog(@&quot;%@ %d&quot;, [NSThread currentThread], i);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">控制台输出：</span><br><span class="line">2019-01-06 15:46:01.790810+0800 GCD_Demo[1797:294279] &lt;NSThread: 0x600002104dc0&gt;&#123;number = 1, name = main&#125; 0</span><br><span class="line">2019-01-06 15:46:01.790974+0800 GCD_Demo[1797:294279] &lt;NSThread: 0x600002104dc0&gt;&#123;number = 1, name = main&#125; 1</span><br><span class="line">2019-01-06 15:46:01.791075+0800 GCD_Demo[1797:294279] &lt;NSThread: 0x600002104dc0&gt;&#123;number = 1, name = main&#125; 2</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="6">
<li><p>在主队列上面同步执行任务：会出现死锁的情况</p>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (void)sync_main_queue &#123;</span><br><span class="line">    dispatch_queue_t queue = dispatch_get_main_queue();</span><br><span class="line">    for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">        dispatch_sync(queue, ^&#123;</span><br><span class="line">            NSLog(@&quot;%@ %d&quot;, [NSThread currentThread], i);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">控制台没有输出，程序crash</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>全局队列属于并发队列，使用起来和并发队列没什么差别，这里不再另行讨论</p>
<h6 id="关于在主队列上面同步执行任务出现死锁的讨论"><a href="#关于在主队列上面同步执行任务出现死锁的讨论" class="headerlink" title="关于在主队列上面同步执行任务出现死锁的讨论"></a>关于在主队列上面同步执行任务出现死锁的讨论</h6><p>有的同学可能会困惑，上面讨论的GCD六种使用方式中，为什么方式6会出现死锁而方式1不会呢？</p>
<p>之所以会出现这种困惑，主要是队列和线程的概念没有分清。</p>
<p>线程是执行任务的，队列是保存任务的，队列遵循严格的FIFO原则。GCD根据队列的类型按照不同的方式取出任务放到线程执行。出现死锁的原因是队列的阻塞而不是线程的阻塞。</p>
<p>下面我画了张图来分析死锁的情况：</p>
<p><img src="/2019/01/06/iOS多线程之：GCD/死锁分析.jpg" alt="死锁分析"></p>
<p>下面来看看串行同步不会引起死锁的分析：</p>
<p><img src="/2019/01/06/iOS多线程之：GCD/串行同步分析.png" alt="串行同步"></p>
<h6 id="栅栏效应："><a href="#栅栏效应：" class="headerlink" title="栅栏效应："></a>栅栏效应：</h6><p>dispatch_barrier针对的是并发队列，但是注意：这个队列不可以是全局队列！！！</p>
<p>barrier就是栅栏的意思，dispatch_barrier可以保证当前队列中只有一个任务在执行中，在前面的任务执行结束后它才执行，而且它后面的任务等它执行完成之后才会执行。</p>
<p>dispatch_barrier提供了两种方式来保证只有一个任务在执行中</p>
<ul>
<li>dispatch_barrier_async</li>
<li>dispatch_barrier_sync</li>
</ul>
<p>区别：dispatch_barrier_async不用等到任务执行完毕就能往下执行，dispatch_barrier_sync要等到添加的任务执行完毕才能继续往下执行。</p>
<p>下面来看我写的一个dispatch_barrier_async_demo和打印效果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (void)dispatch_barrier_async_demo &#123;</span><br><span class="line">    dispatch_queue_t queue = dispatch_queue_create(&quot;gcdtest.rongfzh.yc&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;dispatch_async1&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_barrier_async(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;dispatch_barrier_async_start&quot;);</span><br><span class="line">        [NSThread sleepForTimeInterval:4];</span><br><span class="line">        NSLog(@&quot;dispatch_barrier_async_end&quot;);</span><br><span class="line">        </span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;dispatch_async3&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">控制台打印：</span><br><span class="line">2019-01-13 12:22:28.851753+0800 GCD_Demo[1392:110129] after diapatch barrier</span><br><span class="line">2019-01-13 12:22:28.851754+0800 GCD_Demo[1392:110169] task1</span><br><span class="line">2019-01-13 12:22:28.851869+0800 GCD_Demo[1392:110169] task2 start</span><br><span class="line">2019-01-13 12:22:32.855079+0800 GCD_Demo[1392:110169] task2 end</span><br><span class="line">2019-01-13 12:22:32.855434+0800 GCD_Demo[1392:110169] task3</span><br></pre></td></tr></table></figure>
<p>然后我们dispatch_barrier_async换成dispatch_barrier_sync：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (void)dispatch_barrier_sync_demo &#123;</span><br><span class="line">    dispatch_queue_t queue = dispatch_queue_create(&quot;gcdtest.rongfzh.yc&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;dispatch_async1&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_barrier_async(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;dispatch_barrier_async_start&quot;);</span><br><span class="line">        [NSThread sleepForTimeInterval:4];</span><br><span class="line">        NSLog(@&quot;dispatch_barrier_async_end&quot;);</span><br><span class="line">        </span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;dispatch_async3&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">控制台打印：</span><br><span class="line">2019-01-13 12:23:32.132838+0800 GCD_Demo[1407:112641] task1</span><br><span class="line">2019-01-13 12:23:32.132959+0800 GCD_Demo[1407:112605] task2 start</span><br><span class="line">2019-01-13 12:23:36.134056+0800 GCD_Demo[1407:112605] task2 end</span><br><span class="line">2019-01-13 12:23:36.134298+0800 GCD_Demo[1407:112605] after diapatch barrier</span><br><span class="line">2019-01-13 12:23:36.134507+0800 GCD_Demo[1407:112641] task3</span><br></pre></td></tr></table></figure>
<p><strong>说明：我们在task2中用一个延时操作来模拟耗时的任务，两个demo的区别就是after diapatch barrier的打印时机。通过dispatch_barrier_async方式，after diapatch barrier不用等到task2任务执行完就可以打印；通过dispatch_barrier_async方式，after diapatch barrier要等到task2任务执行完才可以打印。</strong></p>
<p><strong>dispatch_barrier_async的妙用：实现一个多读单写的多线程锁。</strong></p>
<p>多读单写的锁特点：</p>
<ul>
<li>在进行写操作的同时，不能同时有其他写操作或者读操作</li>
<li>允许多个读操作同时进行</li>
</ul>
<p>具体的实现方式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;TestClass.h&quot;</span><br><span class="line"></span><br><span class="line">@interface TestClass ()&#123;</span><br><span class="line">    NSString *_testName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, copy) NSString *testName;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, strong) dispatch_queue_t rw_queue;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@implementation TestClass</span><br><span class="line"></span><br><span class="line">- (instancetype)init</span><br><span class="line">&#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        _rw_queue = dispatch_queue_create(NULL, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setTestName:(NSString *)testName &#123;</span><br><span class="line">    dispatch_barrier_async(_rw_queue, ^&#123;</span><br><span class="line">        _testName = [testName copy];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSString *)testName &#123;</span><br><span class="line">    __block NSString *temp;</span><br><span class="line">    dispatch_sync(_rw_queue, ^&#123;</span><br><span class="line">        temp = _testName;</span><br><span class="line">    &#125;);</span><br><span class="line">    return temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<h6 id="dispatch-once"><a href="#dispatch-once" class="headerlink" title="dispatch_once"></a>dispatch_once</h6><p>dispatch_once用来执行只需要执行一次的任务，常常用来设计单利模式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">用法：</span><br><span class="line">- (void)once</span><br><span class="line">&#123;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">    	//需要单次执行的任务</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="调度组dispatch-group-t"><a href="#调度组dispatch-group-t" class="headerlink" title="调度组dispatch_group_t"></a>调度组dispatch_group_t</h6><p>我们在多线程开发中，经常会遇到在多个任务执行结束后再进行一些总结性的任务操作。这是GCD调度组就可以派上用场了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 实例化一个调度组</span><br><span class="line">dispatch_group_t group = dispatch_group_create();</span><br><span class="line">// 队列</span><br><span class="line">dispatch_queue_t queue = dispatch_get_global_queue(0, 0);</span><br><span class="line">// 任务添加到队列queue</span><br><span class="line">dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">	[NSThread sleepForTimeInterval:4];</span><br><span class="line">    NSLog(@&quot;耗时操作1&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">	[NSThread sleepForTimeInterval:2];</span><br><span class="line">    NSLog(@&quot;耗时操作2&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">	[NSThread sleepForTimeInterval:3];</span><br><span class="line">    NSLog(@&quot;耗时操作3&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_group_notify(group, queue, ^&#123;</span><br><span class="line">	NSLog(@&quot;所有操作都执行完了&quot;); // 异步的</span><br><span class="line">&#125;);</span><br><span class="line">控制台打印：</span><br><span class="line">2019-01-13 14:17:27.840243+0800 GCD_Demo[2498:289933] 耗时操作2</span><br><span class="line">2019-01-13 14:17:28.840083+0800 GCD_Demo[2498:289932] 耗时操作3</span><br><span class="line">2019-01-13 14:17:29.840024+0800 GCD_Demo[2498:289929] 耗时操作1</span><br><span class="line">2019-01-13 14:17:29.840398+0800 GCD_Demo[2498:289929] 所有操作都执行完了</span><br></pre></td></tr></table></figure>
<h6 id="延时操作dispatch-after"><a href="#延时操作dispatch-after" class="headerlink" title="延时操作dispatch_after"></a>延时操作dispatch_after</h6><p>经过某个时间后执行某个任务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dispatch_after(dispatch_time_t when, dispatch_queue_t queue,</span><br><span class="line">		dispatch_block_t block);</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/04/iOS多线程之：NSThread/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DevHuangjb">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="黄锦标的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/04/iOS多线程之：NSThread/" itemprop="url">iOS多线程之：NSThread</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-01-04T23:37:53+08:00">
                2019-01-04
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>线程的概念：线程，有时被称为轻量进程(Lightweight Process，LWP），是程序中一个单一的顺序控制流程。线程是进程中的一个实体，是被系统独立调度和分派的基本单位，线程自己不拥有系统资源，只拥有一点儿在运行中必不可少的资源，但它可与同属一个进程的其它线程共享进程所拥有的全部资源。</strong></p>
<p><strong>在单个程序中同时运行多个线程完成不同的工作，称为多线程。</strong></p>
<p>在iOS开发中，实现多线程的机制常用的有三种：NSThread，GCD dispatch，NSOperation。当然还有底层的pthread。</p>
<p>今天，我们先来聊聊NSThread。</p>
<h6 id="初始化NSThread"><a href="#初始化NSThread" class="headerlink" title="初始化NSThread"></a>初始化NSThread</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)initWithTarget:(id)target selector:(SEL)selector object:(nullable id)argument;</span><br><span class="line">//iOS10新出的api</span><br><span class="line">- (instancetype)initWithBlock:(void (^)(void))block;API_AVAILABLE(macosx(10.12), ios(10.0), watchos(3.0), tvos(10.0));</span><br></pre></td></tr></table></figure>
<p>初始化之后的NSThread要调用start才能开启线程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)start</span><br></pre></td></tr></table></figure>
<p>除了对象初始化方法，苹果还提供了便利的类方法来开启线程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//iOS10新出api</span><br><span class="line">+ (void)detachNewThreadWithBlock:(void (^)(void))block API_AVAILABLE(macosx(10.12), ios(10.0), watchos(3.0), tvos(10.0));</span><br><span class="line">+ (void)detachNewThreadSelector:(SEL)selector toTarget:(id)target withObject:(nullable id)argument;</span><br></pre></td></tr></table></figure>
<p>用类方法调度的线程默认就开启，不用调用start方法来启动。</p>
<h6 id="让线程睡一会："><a href="#让线程睡一会：" class="headerlink" title="让线程睡一会："></a>让线程睡一会：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+ (void)sleepUntilDate:(NSDate *)date;</span><br><span class="line">+ (void)sleepForTimeInterval:(NSTimeInterval)ti;</span><br></pre></td></tr></table></figure>
<h6 id="退出线程"><a href="#退出线程" class="headerlink" title="退出线程"></a>退出线程</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (void)exit;</span><br></pre></td></tr></table></figure>
<p>退出线程后，后面的程序流就不会执行了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void)threadRun:(NSString *)par &#123;</span><br><span class="line">    NSLog(@&quot;start&quot;);</span><br><span class="line">    [NSThread exit];</span><br><span class="line">    NSLog(@&quot;end&quot;);</span><br><span class="line">&#125;</span><br><span class="line">//控制台只输出start，之后线程就退出了</span><br><span class="line">2019-01-05 10:33:01.938485+0800 AnalyzeNSThread[2781:136475] start</span><br></pre></td></tr></table></figure>
<h6 id="取消线程"><a href="#取消线程" class="headerlink" title="取消线程"></a>取消线程</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)cancel;</span><br></pre></td></tr></table></figure>
<p>注意：调用cancel后，并不是直接取消退出线程，而是把线程的isCancelled 标志位置位YES。要退出线程还需要我们自己的线程执行中判断isCancelled然后调用exit来退出线程。</p>
<h6 id="设置线程的优先级"><a href="#设置线程的优先级" class="headerlink" title="设置线程的优先级"></a>设置线程的优先级</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+ (double)threadPriority;</span><br><span class="line">+ (BOOL)setThreadPriority:(double)p;</span><br></pre></td></tr></table></figure>
<p>一般开发中很少会设置线程的优先级，因为有可能会影响到内核调度线程，造成线程执行的卡顿。</p>
<h6 id="线程的属性"><a href="#线程的属性" class="headerlink" title="线程的属性"></a>线程的属性</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">//字典，可以添加其他信息</span><br><span class="line">@property (readonly, retain) NSMutableDictionary *threadDictionary;</span><br><span class="line">//线程的优先级</span><br><span class="line">@property double threadPriority</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">枚举的方式设置线程的优先级</span><br><span class="line">NSQualityOfServiceUserInteractive：最高优先级，主要用于提供交互UI的操作，比如处理点击事件，绘制图像到屏幕上</span><br><span class="line">NSQualityOfServiceUserInitiated：次高优先级，主要用于执行需要立即返回的任务</span><br><span class="line">NSQualityOfServiceDefault：默认优先级</span><br><span class="line">NSQualityOfServiceUtility：普通优先级，主要用于不需要立即返回的任务</span><br><span class="line">NSQualityOfServiceBackground：后台优先级，用于完全不紧急的任务，优先级最低</span><br><span class="line">*/</span><br><span class="line">@property NSQualityOfService qualityOfService</span><br><span class="line"></span><br><span class="line">//线程调用栈函数的返回地址</span><br><span class="line">@property (class, readonly, copy) NSArray&lt;NSNumber *&gt; *callStackReturnAddresses</span><br><span class="line">//线程调用栈函数的名称</span><br><span class="line">@property (class, readonly, copy) NSArray&lt;NSString *&gt; *callStackSymbols</span><br><span class="line">//线程名称</span><br><span class="line">@property (nullable, copy) NSString *name</span><br><span class="line">//线程栈大小</span><br><span class="line">@property NSUInteger stackSize</span><br><span class="line"></span><br><span class="line">@property (readonly) BOOL isMainThread</span><br><span class="line">@property (class, readonly) BOOL isMainThread</span><br><span class="line">@property (class, readonly, strong) NSThread *mainThread</span><br><span class="line"></span><br><span class="line">//线程是否执行中</span><br><span class="line">@property (readonly, getter=isExecuting) BOOL executing</span><br><span class="line">//线程是否结束</span><br><span class="line">@property (readonly, getter=isFinished) BOOL finished</span><br><span class="line">//线程是否取消</span><br><span class="line">@property (readonly, getter=isCancelled) BOOL cancelled</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/04/SDWebImage解析之SDWebImageDownloader/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DevHuangjb">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="黄锦标的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/04/SDWebImage解析之SDWebImageDownloader/" itemprop="url">SDWebImage解析之SDWebImageDownloader</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-01-04T19:02:05+08:00">
                2019-01-04
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>SDWebImageDownloaderOperation是针对图片的某个具体的下载任务。SDWebImageDownloader角色则是类似于一个下载器，可以发起执行一个或多个下载任务，并对这些任务进行管理：任务的执行顺序，停止任务，取消任务，控制任务的并发量等。</p>
<p><strong>首先来看一下SDWebImageDownloader.h头文件</strong></p>
<p>定义了一个下载的配置选项SDWebImageDownloaderOptions</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_OPTIONS(NSUInteger, SDWebImageDownloaderOptions) &#123;</span><br><span class="line">//下载优先级低</span><br><span class="line">    SDWebImageDownloaderLowPriority = 1,</span><br><span class="line">    SDWebImageDownloaderLowPriority = 2,</span><br><span class="line">    //渐进式的解码下载图片</span><br><span class="line">    SDWebImageDownloaderProgressiveDownload = 1 &lt;&lt; 1,</span><br><span class="line">    //配置了这个选项就会使用系统默认的缓存机制，否则使用SDImageCache缓存</span><br><span class="line">    SDWebImageDownloaderUseNSURLCache = 1 &lt;&lt; 2,</span><br><span class="line">    //结合SDWebImageDownloaderUseNSURLCache选项，忽略缓存的图片</span><br><span class="line">    SDWebImageDownloaderIgnoreCachedResponse = 1 &lt;&lt; 3,</span><br><span class="line">    //当app退到后台，申请后台继续下载</span><br><span class="line">    SDWebImageDownloaderContinueInBackground = 1 &lt;&lt; 4,</span><br><span class="line">    //设置NSMutableURLRequest.HTTPShouldHandleCookies = YES;</span><br><span class="line">    SDWebImageDownloaderHandleCookies = 1 &lt;&lt; 5,</span><br><span class="line">    //允许非法证书请求</span><br><span class="line">    SDWebImageDownloaderAllowInvalidSSLCertificates = 1 &lt;&lt; 6,</span><br><span class="line">    //下载优先级高</span><br><span class="line">    SDWebImageDownloaderHighPriority = 1 &lt;&lt; 7,</span><br><span class="line">    //如果下载的图片太大(大于60M)则对图片进行缩小</span><br><span class="line">    SDWebImageDownloaderScaleDownLargeImages = 1 &lt;&lt; 8,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>下面是任务执行的顺序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSInteger, SDWebImageDownloaderExecutionOrder) &#123;</span><br><span class="line">//先入先出</span><br><span class="line">    SDWebImageDownloaderFIFOExecutionOrder,</span><br><span class="line">    //先入后出</span><br><span class="line">    SDWebImageDownloaderLIFOExecutionOrder</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里有个类SDWebImageDownloadToken 用于关联某个特定的SDWebImageDownloaderOperation，可以让外界方便的取消下载中的任务。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//这个类遵守SDWebImageOperation协议，实现了cancel方法</span><br><span class="line">@interface SDWebImageDownloadToken : NSObject &lt;SDWebImageOperation&gt;</span><br><span class="line">//图片url</span><br><span class="line">@property (nonatomic, strong, nullable) NSURL *url;</span><br><span class="line">//SDWebImageDownloaderOperation： - (nullable id)addHandlersForProgress:completed:后返回的字典结构，里面包含这个operation的progressBlock和completedBlock</span><br><span class="line">@property (nonatomic, strong, nullable) id downloadOperationCancelToken;</span><br><span class="line">//关联的SDWebImageDownloaderOperation</span><br><span class="line">@property (nonatomic, weak, nullable) NSOperation&lt;SDWebImageDownloaderOperationInterface&gt; *downloadOperation;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation SDWebImageDownloadToken</span><br><span class="line">- (void)cancel &#123;</span><br><span class="line">    if (self.downloadOperation) &#123;</span><br><span class="line">        SDWebImageDownloadToken *cancelToken = self.downloadOperationCancelToken;</span><br><span class="line">        if (cancelToken) &#123;</span><br><span class="line">        //调用SDWebImageDownloaderOperation的 cancel:方法来移除回调函数，当所有回调函数都移除了，这个下载任务就会被取消掉</span><br><span class="line">            [self.downloadOperation cancel:cancelToken];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>下面来看看SDWebImageDownloader向外部暴露的属性和方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">@interface SDWebImageDownloader : NSObject</span><br><span class="line">//是否要对下载的图片预绘制解码</span><br><span class="line">@property (assign, nonatomic) BOOL shouldDecompressImages;</span><br><span class="line">//最大并发下载数</span><br><span class="line">@property (assign, nonatomic) NSInteger maxConcurrentDownloads;</span><br><span class="line">//当前下载任务数</span><br><span class="line">@property (readonly, nonatomic) NSUInteger currentDownloadCount;</span><br><span class="line">//超市时间,默认15s</span><br><span class="line">@property (assign, nonatomic) NSTimeInterval downloadTimeout;</span><br><span class="line">//内部用于配置NSUrlSession的NSURLSessionConfiguration</span><br><span class="line">@property (readonly, nonatomic, nonnull) NSURLSessionConfiguration *sessionConfiguration;</span><br><span class="line">//任务的执行顺序</span><br><span class="line">@property (assign, nonatomic) SDWebImageDownloaderExecutionOrder executionOrder;</span><br><span class="line">//单例获取</span><br><span class="line">+ (nonnull instancetype)sharedDownloader;</span><br><span class="line">//https证书</span><br><span class="line">@property (strong, nonatomic, nullable) NSURLCredential *urlCredential;</span><br><span class="line">@property (strong, nonatomic, nullable) NSString *username;</span><br><span class="line">@property (strong, nonatomic, nullable) NSString *password;</span><br><span class="line">//用于过滤http请求头参数</span><br><span class="line">@property (nonatomic, copy, nullable) SDWebImageDownloaderHeadersFilterBlock headersFilter;</span><br><span class="line">//</span><br><span class="line">- (nonnull instancetype)initWithSessionConfiguration:(nullable NSURLSessionConfiguration *)sessionConfiguration NS_DESIGNATED_INITIALIZER;</span><br><span class="line">//设置http请求头参数</span><br><span class="line">- (void)setValue:(nullable NSString *)value forHTTPHeaderField:(nullable NSString *)field;</span><br><span class="line">//获取指定http请求头信息</span><br><span class="line">- (nullable NSString *)valueForHTTPHeaderField:(nullable NSString *)field;</span><br><span class="line">//指定自定义的下载类</span><br><span class="line">- (void)setOperationClass:(nullable Class)operationClass;</span><br><span class="line">//下载图片，设置下载选项，指定回调block</span><br><span class="line">- (nullable SDWebImageDownloadToken *)downloadImageWithURL:(nullable NSURL *)url</span><br><span class="line">                                                   options:(SDWebImageDownloaderOptions)options</span><br><span class="line">                                                  progress:(nullable SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                                                 completed:(nullable SDWebImageDownloaderCompletedBlock)completedBlock;</span><br><span class="line">//取消</span><br><span class="line">- (void)cancel:(nullable SDWebImageDownloadToken *)token;</span><br><span class="line">//暂停</span><br><span class="line">- (void)setSuspended:(BOOL)suspended;</span><br><span class="line">//取消所有下载任务</span><br><span class="line">- (void)cancelAllDownloads;</span><br><span class="line">//重新指定NSURLSessionConfiguration配置NSUrlSession</span><br><span class="line">- (void)createNewSessionWithConfiguration:(nonnull NSURLSessionConfiguration *)sessionConfiguration;</span><br><span class="line">//使NSUrlSession失效，cancelPendingOperations：是否取消下载中的任务</span><br><span class="line">- (void)invalidateSessionAndCancel:(BOOL)cancelPendingOperations;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>接下来看看SDWebImageDownloader 的实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@interface SDWebImageDownloader () &lt;NSURLSessionTaskDelegate, NSURLSessionDataDelegate&gt;</span><br><span class="line">@property (strong, nonatomic, nonnull) NSOperationQueue *downloadQueue;</span><br><span class="line">//最后添加的任务：当指定为LIFO，如果有新下载任务，则之前最后添加的任务会依赖于新任务执行完达到LIFO效果</span><br><span class="line">@property (weak, nonatomic, nullable) NSOperation *lastAddedOperation;</span><br><span class="line">//自定义的下载类</span><br><span class="line">@property (assign, nonatomic, nullable) Class operationClass;</span><br><span class="line">//管理的下载任务集合</span><br><span class="line">@property (strong, nonatomic, nonnull) NSMutableDictionary&lt;NSURL *, SDWebImageDownloaderOperation *&gt; *URLOperations;</span><br><span class="line">//request请求头</span><br><span class="line">@property (strong, nonatomic, nullable) SDHTTPHeadersMutableDictionary *HTTPHeaders;</span><br><span class="line">//保证任务集合在多线程数据安全所用的信号量</span><br><span class="line">@property (strong, nonatomic, nonnull) dispatch_semaphore_t operationsLock; </span><br><span class="line">//保证HTTPHeaders在多线程数据安全所用的信号量</span><br><span class="line">@property (strong, nonatomic, nonnull) dispatch_semaphore_t headersLock; </span><br><span class="line">@property (strong, nonatomic) NSURLSession *session;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>在initialize中为请求添加指示器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">+ (void)initialize &#123;</span><br><span class="line">    // 我们需要额外导入SDNetworkActivityIndicator.h</span><br><span class="line">    if (NSClassFromString(@&quot;SDNetworkActivityIndicator&quot;)) &#123;</span><br><span class="line"></span><br><span class="line">#pragma clang diagnostic push</span><br><span class="line">#pragma clang diagnostic ignored &quot;-Warc-performSelector-leaks&quot;</span><br><span class="line">		//通过runtime来实例化一个指示器</span><br><span class="line">        id activityIndicator = [NSClassFromString(@&quot;SDNetworkActivityIndicator&quot;) performSelector:NSSelectorFromString(@&quot;sharedActivityIndicator&quot;)];</span><br><span class="line">#pragma clang diagnostic pop</span><br><span class="line"></span><br><span class="line">        // 因为指示器是用sharedActivityIndicator获取的单例，添加监听前先移除</span><br><span class="line">        [[NSNotificationCenter defaultCenter] removeObserver:activityIndicator name:SDWebImageDownloadStartNotification object:nil];</span><br><span class="line">        [[NSNotificationCenter defaultCenter] removeObserver:activityIndicator name:SDWebImageDownloadStopNotification object:nil];</span><br><span class="line">        [[NSNotificationCenter defaultCenter] addObserver:activityIndicator</span><br><span class="line">                                                 selector:NSSelectorFromString(@&quot;startActivity&quot;)</span><br><span class="line">                                                     name:SDWebImageDownloadStartNotification object:nil];</span><br><span class="line">        [[NSNotificationCenter defaultCenter] addObserver:activityIndicator</span><br><span class="line">                                                 selector:NSSelectorFromString(@&quot;stopActivity&quot;)</span><br><span class="line">                                                     name:SDWebImageDownloadStopNotification object:nil];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面来看构造函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">- (nonnull instancetype)initWithSessionConfiguration:(nullable NSURLSessionConfiguration *)sessionConfiguration &#123;</span><br><span class="line">    if ((self = [super init])) &#123;</span><br><span class="line">        _operationClass = [SDWebImageDownloaderOperation class];</span><br><span class="line">        //默认预绘制解码下载图片</span><br><span class="line">        _shouldDecompressImages = YES;</span><br><span class="line">        //默认FIFO执行顺序</span><br><span class="line">        _executionOrder = SDWebImageDownloaderFIFOExecutionOrder;</span><br><span class="line">        _downloadQueue = [NSOperationQueue new];</span><br><span class="line">        //默认并发数为6</span><br><span class="line">        _downloadQueue.maxConcurrentOperationCount = 6;</span><br><span class="line">        _downloadQueue.name = @&quot;com.hackemist.SDWebImageDownloader&quot;;</span><br><span class="line">        _URLOperations = [NSMutableDictionary new];</span><br><span class="line">#ifdef SD_WEBP</span><br><span class="line">        _HTTPHeaders = [@&#123;@&quot;Accept&quot;: @&quot;image/webp,image/*;q=0.8&quot;&#125; mutableCopy];</span><br><span class="line">#else</span><br><span class="line">        _HTTPHeaders = [@&#123;@&quot;Accept&quot;: @&quot;image/*;q=0.8&quot;&#125; mutableCopy];</span><br><span class="line">#endif</span><br><span class="line">        _operationsLock = dispatch_semaphore_create(1);</span><br><span class="line">        _headersLock = dispatch_semaphore_create(1);</span><br><span class="line">        //默认超时时间15s</span><br><span class="line">        _downloadTimeout = 15.0;</span><br><span class="line">        [self createNewSessionWithConfiguration:sessionConfiguration];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面来看看如何发起和管理一个下载任务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (nullable SDWebImageDownloadToken *)downloadImageWithURL:(nullable NSURL *)url</span><br><span class="line">                                                   options:(SDWebImageDownloaderOptions)options</span><br><span class="line">                                                  progress:(nullable SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                                                 completed:(nullable SDWebImageDownloaderCompletedBlock)completedBlock</span><br></pre></td></tr></table></figure>
<p>内部调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (nullable SDWebImageDownloadToken *)addProgressCallback:(SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                                           completedBlock:(SDWebImageDownloaderCompletedBlock)completedBlock</span><br><span class="line">                                                   forURL:(nullable NSURL *)url</span><br><span class="line">                                           createCallback:(SDWebImageDownloaderOperation *(^)(void))createCallback</span><br></pre></td></tr></table></figure>
<p>来为一个SDWebImageDownloaderOperation 添加progressBlock和completedBlock。同时传递了一个createCallback来实例化一个SDWebImageDownloaderOperation。</p>
<p>我们来看看如何实例化一个SDWebImageDownloaderOperation:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">__strong __typeof (wself) sself = wself;</span><br><span class="line"> NSTimeInterval timeoutInterval = sself.downloadTimeout;</span><br><span class="line"> if (timeoutInterval == 0.0) &#123;</span><br><span class="line">     timeoutInterval = 15.0;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> // 是否使用系统默认的缓存策略</span><br><span class="line"> NSURLRequestCachePolicy cachePolicy = options &amp; SDWebImageDownloaderUseNSURLCache ? NSURLRequestUseProtocolCachePolicy : NSURLRequestReloadIgnoringLocalCacheData;</span><br><span class="line"> NSMutableURLRequest *request = [[NSMutableURLRequest alloc] initWithURL:url</span><br><span class="line">                                                             cachePolicy:cachePolicy</span><br><span class="line">                                                         timeoutInterval:timeoutInterval];</span><br><span class="line"> </span><br><span class="line"> request.HTTPShouldHandleCookies = (options &amp; SDWebImageDownloaderHandleCookies);</span><br><span class="line"> request.HTTPShouldUsePipelining = YES;</span><br><span class="line"> if (sself.headersFilter) &#123;</span><br><span class="line"> //如果指定过滤请求头，使用block过滤</span><br><span class="line">     request.allHTTPHeaderFields = sself.headersFilter(url, [sself allHTTPHeaderFields]);</span><br><span class="line"> &#125;</span><br><span class="line"> else &#123;</span><br><span class="line">     request.allHTTPHeaderFields = [sself allHTTPHeaderFields];</span><br><span class="line"> &#125;</span><br><span class="line"> SDWebImageDownloaderOperation *operation = [[sself.operationClass alloc] initWithRequest:request inSession:sself.session options:options];</span><br><span class="line"> operation.shouldDecompressImages = sself.shouldDecompressImages;</span><br><span class="line"> </span><br><span class="line"> if (sself.urlCredential) &#123;</span><br><span class="line">     operation.credential = sself.urlCredential;</span><br><span class="line"> &#125; else if (sself.username &amp;&amp; sself.password) &#123;</span><br><span class="line">     operation.credential = [NSURLCredential credentialWithUser:sself.username password:sself.password persistence:NSURLCredentialPersistenceForSession];</span><br><span class="line"> &#125;</span><br><span class="line"> //通过下载选项配置请求优先级</span><br><span class="line"> if (options &amp; SDWebImageDownloaderHighPriority) &#123;</span><br><span class="line">     operation.queuePriority = NSOperationQueuePriorityHigh;</span><br><span class="line"> &#125; else if (options &amp; SDWebImageDownloaderLowPriority) &#123;</span><br><span class="line">     operation.queuePriority = NSOperationQueuePriorityLow;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> if (sself.executionOrder == SDWebImageDownloaderLIFOExecutionOrder) &#123;</span><br><span class="line"> //指定LIFO</span><br><span class="line">     [sself.lastAddedOperation addDependency:operation];</span><br><span class="line">     sself.lastAddedOperation = operation;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> return operation;</span><br></pre></td></tr></table></figure>
<p>下面来看看如何关联回调block:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">- (nullable SDWebImageDownloadToken *)addProgressCallback:(SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                                           completedBlock:(SDWebImageDownloaderCompletedBlock)completedBlock</span><br><span class="line">                                                   forURL:(nullable NSURL *)url</span><br><span class="line">                                           createCallback:(SDWebImageDownloaderOperation *(^)(void))createCallback &#123;</span><br><span class="line">    if (url == nil) &#123;</span><br><span class="line">        if (completedBlock != nil) &#123;</span><br><span class="line">            completedBlock(nil, nil, nil, NO);</span><br><span class="line">        &#125;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    LOCK(self.operationsLock);</span><br><span class="line">    //首先确认下这个operation是否已经在任务集合中，保证当前针对一个url只有一个下载任务，防止同一时刻反复下载一张图片</span><br><span class="line">    SDWebImageDownloaderOperation *operation = [self.URLOperations objectForKey:url];</span><br><span class="line">    if (!operation || operation.isFinished) &#123;</span><br><span class="line">        operation = createCallback();</span><br><span class="line">        __weak typeof(self) wself = self;</span><br><span class="line">        operation.completionBlock = ^&#123;</span><br><span class="line">            __strong typeof(wself) sself = wself;</span><br><span class="line">            if (!sself) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            LOCK(sself.operationsLock);</span><br><span class="line">            [sself.URLOperations removeObjectForKey:url];</span><br><span class="line">            UNLOCK(sself.operationsLock);</span><br><span class="line">        &#125;;</span><br><span class="line">        [self.URLOperations setObject:operation forKey:url];</span><br><span class="line">        //添加到下载队列，开始下载</span><br><span class="line">        [self.downloadQueue addOperation:operation];</span><br><span class="line">    &#125;</span><br><span class="line">    UNLOCK(self.operationsLock);</span><br><span class="line">	</span><br><span class="line">//为operation增加回调block</span><br><span class="line">    id downloadOperationCancelToken = [operation addHandlersForProgress:progressBlock completed:completedBlock];</span><br><span class="line">    //配置SDWebImageDownloadToken，包装了回调函数，operation,url。返回给外包调用者来管理下载任务</span><br><span class="line">    SDWebImageDownloadToken *token = [SDWebImageDownloadToken new];</span><br><span class="line">    token.downloadOperation = operation;</span><br><span class="line">    token.url = url;</span><br><span class="line">    token.downloadOperationCancelToken = downloadOperationCancelToken;</span><br><span class="line"></span><br><span class="line">    return token;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于NSURLSession代理方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark NSURLSessionDataDelegate</span><br><span class="line"></span><br><span class="line">- (void)URLSession:(NSURLSession *)session</span><br><span class="line">          dataTask:(NSURLSessionDataTask *)dataTask</span><br><span class="line">didReceiveResponse:(NSURLResponse *)response</span><br><span class="line"> completionHandler:(void (^)(NSURLSessionResponseDisposition disposition))completionHandler &#123;</span><br><span class="line">    SDWebImageDownloaderOperation *dataOperation = [self operationWithTask:dataTask];</span><br><span class="line">    if ([dataOperation respondsToSelector:@selector(URLSession:dataTask:didReceiveResponse:completionHandler:)]) &#123;</span><br><span class="line">        [dataOperation URLSession:session dataTask:dataTask didReceiveResponse:response completionHandler:completionHandler];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (completionHandler) &#123;</span><br><span class="line">            completionHandler(NSURLSessionResponseAllow);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>都是通过这种形式来把代理操作转发到SDWebImageDownloaderOperation的代理方法里面去执行。</p>
<p>operationWithTask通过NSURLSessionTask的taskIdentifier匹配来找出相对应的SDWebImageDownloaderOperation。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (SDWebImageDownloaderOperation *)operationWithTask:(NSURLSessionTask *)task &#123;</span><br><span class="line">    SDWebImageDownloaderOperation *returnOperation = nil;</span><br><span class="line">    for (SDWebImageDownloaderOperation *operation in self.downloadQueue.operations) &#123;</span><br><span class="line">        if (operation.dataTask.taskIdentifier == task.taskIdentifier) &#123;</span><br><span class="line">            returnOperation = operation;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return returnOperation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.gif" alt="DevHuangjb">
            
              <p class="site-author-name" itemprop="name">DevHuangjb</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/DevHuangjb" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.jianshu.com/u/ba146c0c3280" target="_blank" title="简书">
                      
                        <i class="fa fa-fw fa-globe"></i>简书</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">DevHuangjb</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
